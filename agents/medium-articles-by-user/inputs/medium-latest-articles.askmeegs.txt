
== Article 1
* Title: 'One Year in Cloud Developer Relations'
* Author: 'Megan Oâ€™Keefe'
* URL: 'https://medium.com/@askmeegs/one-year-in-devrel-21b516fdaa05?source=rss-db638f78c20f------2'
* PublicationDate: 'Tue, 03 Sep 2019 14:57:09 GMT'
* Categories: developer-relations, google-cloud-platform, developer, software-engineering, career-advice

Last August, I moved from Software Engineering to a role in Developer Relations at Google Cloud. Since then, I have helped users adopt technologies like Istio, moved across the country (twice), spoken at multiple conferences, turned twenty-five, and became my teamâ€™s techÂ lead.at Google Cloud NEXTÂ â€˜19Itâ€™s been a fun, challenging year. Here are four lessons Iâ€™ve learned along theÂ way.1) Willingness to learn &gt; everything else.When I started in this role, I was worried that I didnâ€™t have enough experience. I had only been a â€œrealâ€ software engineer for two years, and at Google, I was immediately surrounded by smart, qualified people, many with years of experience. I felt like I had an impossible amount to learn in order to catchÂ up.sourceBut hereâ€™s the thing. You donâ€™t have to know everything about a certain technology or product in order to do effective DevRel. Developer Relations is about empathyâ€Šâ€”â€Šlistening to usersâ€Šâ€”â€Šand then forwarding their feedback to product teams. Itâ€™s also about creating content, whether thatâ€™s building new tools or samples, writing a tutorial, running an empathy session, or giving a talk. So usually, by the time youâ€™re creating content, youâ€™ve already built up expertise about the product or feature in question.In my case, listening to why customers were interested in Istio, and the successes and challenges they had adopting it, was one of the best ways to learn about the project. I learned quickly what a service mesh was for, and in the process of reading the docs, had fresh eyes for where gaps existed in theÂ product.I think that for DevRel, more important than having a brain full of knowledge is a readiness to learn from users. The tech industry can change quickly, and you might do DevRel for many products over time. I donâ€™t think you need many years of experience to create impactful content. But I think you do have to invest the time to continuously pick up new technologies.sourceStill, there will always be questions you canâ€™t answerâ€Šâ€”â€Šhow does Firestore work with Kubernetes? What is SOAP??â€Šâ€”â€Šand for those questions, I can turn to one of my awesome colleagues. Almost always, they can point me in the right direction. Which brings meÂ to:2) PeopleÂ matter.DevRel can sometimes feel solitary. Because there are a lot of users to hear from, those connections can be short-lived. There is a not-insignificant amount of travel, and often, my teammates and I are working on different projects, with different teams.I think the nature of DevRel raises the stakes on the people you work with. Why? Because I think that in order to feel supported at work, you need a safe place to land: places where you can share triumphs and struggles, ask for feedback, engage in off-topic discussions aboutÂ baking.And these relationships can go two ways: you can TA your teammatesâ€™ workshops, summarize articles for a group chat, help other DevRellers practice their talks, answer their questions (Whatâ€™s a PVC??). I have been lucky to have multiple mentors since joining Google, who encouraged me to start communicating feedback to product teams within a few weeks of my start date. I am so grateful for them, and for the confidence they helped me build earlyÂ on.sourceIn DevRel, there are also lots of other people, internally, to talk to. For me, this means the partner teams for the Google products I represent externally. This includes product managers, engineers, tech writers, marketing. These are the people I usually talk to most during any given weekday. For this reason, it matters a lot to work with a product team that is receptive to your feedback, interested in DevRelâ€™s help, willing to answer questions, willing to invite you to customer meetings, and excited about improving theirÂ product.3) Your calendar is not yourÂ friend.When I moved into this role from Software Engineering, the most drastic difference in my working life was not the programming languages I used, or the products I worked with. It was meetings.On an average weekday, I have 6â€“8 meetings: with users, the open-source community, product managers, engineering leads, UX researchers, and my own team withinÂ DevRel.Iâ€™m an introvert, so meetings drain my battery, even if in a good way, and they can also disrupt uninterrupted time to write code, create new content, and otherwise think deeply about things. This means that I have to protect myÂ time.sourceBecause I sit on the east coast and most of my colleagues are out west, I usually have a few quiet hours in the morning to get things done. But I certainly have not mastered time management for DevRel; I find it especially challenging to decline meetings with people Iâ€™m actively working with. I donâ€™t want to let them down, or make it look like I donâ€™t care! If you have advice about this, do comment downÂ below.4) Work-life balance getsÂ tougher.DevRel is a people job. My job is not to sell products, or to build them. Itâ€™s to connect people to Googleâ€™s technology, hear from them about how theyâ€™re using it, what they donâ€™t like, and then to make things better. This means that often, you might hear more about the â€œbadâ€ than the â€œgood.â€ I think this can lead to a mindset of obligation to fix all the things. Especially true if the total DevRel footprint for a certain product isÂ small.Also, there will probably be an endless backlog of things to do. There will be features to champion, bugs to file, docs to review, tweets to compose. All of this, coupled with the fact that I really like my job, makes work-life balance much harder than it was when I was a Software Engineer.sourceThe best strategy Iâ€™ve learned to cope with this is pretty simple, which is to leave work at the office as much as possible, not have anything work-related on my phone, and use my weekends to actively spend time with friends and family, do fun things, and sleep. Sleep is important. But again, I havenâ€™t totally figured this out. Actually this is the thing I definitely have not figuredÂ out.Working in Developer Relations has helped me grow in many ways, and Iâ€™m grateful to all my colleagues for making my first year a greatÂ one.That said, no job is perfect. There are tradeoffs. Iâ€™m definitely writing less code than before. But every day, I get to flex a different set of musclesâ€Šâ€”â€Šwriting code, writing prose, trying out products, active listening, engaging a customer, debugging bad YAML, public speaking. For me, at this stage in my career, DevRel is the right place for me to be, and I canâ€™t wait to see what the next year has inÂ store.sourceNote: This post also appears on my personalÂ blog.

== Article 2
* Title: 'Building My Own Notes App (Glitch, Kubernetes)'
* Author: 'Megan Oâ€™Keefe'
* URL: 'https://medium.com/@askmeegs/building-my-own-notes-app-glitch-kubernetes-bdd340af46c7?source=rss-db638f78c20f------2'
* PublicationDate: 'Tue, 21 May 2019 17:01:47 GMT'
* Categories: kubernetes, firestore, web-development, golang, glitch

TLDR: Code is here (frontend) and here (backend).Iâ€™ve used lots of notes apps. Simplenote. nvALT. Bear. Apple Notes. And theyâ€™ve worked well enough. But lately Iâ€™ve been looking for twoÂ things:A programmatic way to read/write notesÂ (API)A way to see a random note from the past (for inspiration)Right now, Iâ€™m using Apple Notes across all my devices, which is locked down re: programmatic access. So I knew it was time for a change. To take a first stab at the problem, I wrote my own private notes server, with an accompanying frontend.DesignMy requirements wereÂ minimal:Create + view notes. (And notes can be immutable; no need toÂ edit.)View a randomÂ noteHTTPS everywhere. Also, the frontend must be locked down with a loginÂ screen.Here is where IÂ landed:Notes App ArchitectureğŸ’» FrontendI chose to use Glitch to create (and host) my notes frontend. Iâ€™ve heard great things about Glitchâ€Šâ€”â€Šitâ€™s a community of developers/apps, but also way to create free, fully-hosted web apps without having to deal with npm, etc. on my own machine. I think my use case (a â€œhacking on the webâ€ / side-project sort of app) was a great fit for Glitch, and Iâ€™d definitely recommend it.My JavaScript is rusty, so writing the frontend took the most time out of this whole process. (Code here.) For the server-side, I settled on a set of express.js endpoints (node.js), rendered via pug.js. The express functions use axios.js to call the backend notesÂ server.On the client-side, I used jQuery for my button listeners. I also used DataTables to add search (and sorting) to my list ofÂ notes:My favorite thing about writing the frontend was creating the Pug views. So simple! Hereâ€™s where I show a randomÂ note:div.one      if error         h4= error       if note         h1 a note from the past        div.one          p.randomText= note.noteâ€¦ Which rendersÂ to:Finally, the whole frontend is locked down with a login screen, which authenticates with the backend, and stores a JWT as a cookie. This cookie is used for all subsequent calls to theÂ Backendâ€¦â˜¸ï¸ BackendI could have just had my Node.js backend call the database directly. But for more practice, I wrote a server backend in Golang (code here). Then, I deployed the backend to Kubernetes, beneath a domain name I had lyingÂ around.The backend is a dead-simple golang HTTP server that speaks JSON (I didnâ€™t use any API frameworks or generators). For instance, the handler for getting all the notes looks likeÂ this:// GetNotesHandler gets all notesfunc GetNotesHandler(w http.ResponseWriter, r *http.Request) { w.Header().Set("Access-Control-Allow-Origin", "*") w.Header().Set("Content-Type", "application/json")if err := validateJwt(r); err != nil {  w.WriteHeader(http.StatusUnauthorized)  io.WriteString(w, err.Error())  return }notes, err := getNotesHelper() if err != nil {  w.WriteHeader(http.StatusInternalServerError)  io.WriteString(w, err.Error()) }output, _ := json.Marshal(notes)w.WriteHeader(http.StatusOK) io.WriteString(w, string(output))}All calls to the server must have a valid JWT, issued via the POST /loginendpoint.Then, I wrote a simple Dockerfile to containerize the server, then pushed it to my image repo (in Google Container Registry).Next, I knew Iâ€™d have to deploy this Docker container somewhere. I know Kubernetes, so I chose to deploy to GKE out of convenience. But Kubernetes was probably overkill for my use case (see: relevant tweet), because Iâ€™m the only user of my backend server, and I probably wonâ€™t generate a lot of requests.Using GKE, however, allowed me to set up Managed SSL certificates for my domain, using the Kubernetes Ingress resource, and a GCP static IP address. Meaning I could hit https://&lt;my-domain-name&gt; and reach my backend server. This came in handy when it came time to connect my Glitch frontend to the backend (Glitch doesnâ€™t allow plain http calls.). The alternative, here, would be to use LetsEncrypt or another certificate authority for yourÂ domain.Finally, hereâ€™s my Kubernetes deployment YAML, which actually deploys the backend server container into my Kubernetes cluster:     containers:      - name: server        image:  gcr.io/notesdb/notes:v0.0.4        imagePullPolicy: Always        ports:        - containerPort: 8080        volumeMounts:        - name: firestore-key          mountPath: /var/secrets/googleWhatâ€™s that /var/secrets/google? Itâ€™s a mounted-in Kubernetes secret, which I added to my cluster ahead of time. This secret contains the credentials needed to talk to the databaseâ€¦ğŸ“ DatabaseMy notes have to live somewhere, so for a database I chose Firestore, which is Google Cloudâ€™s newer NoSQL database for web and mobile. I chose Firestore mostly because Iâ€™d never tried it before; I could have also used Google Cloud Datastore or some other NoSQL database.The DB itself lives in the same Google Cloud project as my Kubernetes cluster, and itâ€™s a single collection with a bunch of documents. Each document represents oneÂ Note.My backend code uses the Firestore client library for Golang. This was really easy to useâ€Šâ€”â€Šyou just need a service account key, and you can start writing documents to your collection, likeÂ this:n := Note{  Timestamp: time.Now().Format(time.RFC3339),  Note:      note.Note, }_, _, err = client.Collection("notes").Add(context.Background(), n)Thatâ€™s aÂ wrap!This was a fun weekend project. And while thereâ€™s a lot I want to improve (a better mobile UX, render embedded links in the frontend), Iâ€™m happy with my app soÂ far.âœ¨ Thanks forÂ reading!This post originally appeared at https://askmeegs.dev/posts/notes-project/Â .

== Article 3
* Title: 'A Kubernetes Development Workflow for MacOS '
* Author: 'Megan Oâ€™Keefe'
* URL: 'https://medium.com/@askmeegs/a-kubernetes-development-workflow-for-macos-8c41669a4518?source=rss-db638f78c20f------2'
* PublicationDate: 'Thu, 24 Jan 2019 17:05:48 GMT'
* Categories: docker, macos, kubernetes, kubectl, containers

ğŸ’» A Kubernetes Developer Workflow forÂ MacOSKubernetes development is not one-size-fits-all. Maybe youâ€™re learning Kubernetes with Minikube on your local machine; maybe youâ€™re part of a large organization with many clusters; maybe your cluster is an on-prem lab, or lives in theÂ cloud.But whether youâ€™re a cluster operator managing policies, an app developer test-driving a new service, or a data scientist running Kubeflow, chances are you are doing some (or all) of: connecting to a cluster, inspecting its state, creating resources, and debugging those resources.As a developer relations engineer for Kubernetes, I work a lot with demo code, samples, and sandbox clusters. This can get interesting to keep track of (read: total chaos). So in this post Iâ€™ll show some of the tools that make my Kubernetes life a lotÂ better.This environment can work no matter what flavor of Kubernetes youâ€™re running, and all these tools are made possible by the amazing open source community.ğŸ’» terminalI use iterm2 with the palenight color scheme. On top of that, Iâ€™m running zsh and oh_my_zsh with the default robby-russell theme.This theme has basic Git support but is otherwise minimal. If youâ€™re interested in displaying your current Kubernetes context in your shell prompt, check out kube-ps1 or the spaceship prompt.Second, my ~/.zshrc file has an essential line:source &lt;(kubectl completion zsh)This enables tab completion for kubectl commands. No more copy-pasting podÂ names!ğŸ›¶ navigating clustersOn any given day, I might switch between three clusters. This might describe you too! Do you get annoyed anytime you have to open your kubeconfig?Same! Luckily, there is kubectx for exactly thisÂ purpose:kubectxkubectx lets you navigate between cluster contexts easily. My favorite thing is running kubectx -, which takes you to the cluster you were usingÂ last.âš¡ï¸ superpowered kubectlNow that weâ€™ve got a cluster to work with, letâ€™s doÂ stuff.Maybe youâ€™ve felt that kubectl commands can get very long, with lots of command-line flags. I have found that kubectl tab completion, plus a comprehensive set of aliases (command shortcuts), helps aÂ lot.Here is a great list of kubectl aliases, that lets you run thingsÂ like:get podsdescribe podFinally, I use a few kubectl plugins. But manually setting these up can get annoying. So I use krew, an open-source plugin manager forÂ kubectl:krewkrew lets you browse, install, and use kubectl plugins, so that you can run custom commands.ğŸ“œ wrangling yamlNow that we have a cluster ready to go, letâ€™s deploy something.Developing on Kubernetes means writing, managing, updating, and deploying lots of YAML files. I keep all my YAML files in Git. Adopting GitOps early (rather than keeping files locally) lets me see revision history as Iâ€™m doing early debugging, and sets me up for success later if/when I start formalizing a pipeline for the application Iâ€™m working on. (example: a Github webhook for a CI/CD pipeline.)I use VSCode as my text editor, plus the Moonlight theme. And while VSCode has a ton of great features on its own, Red Hatâ€™s YAML Support plugin is very handy for validation, autocompletion, and formatting.Right now my process of writing Kubernetes YAML is fairly manual. But usually for every new project, Iâ€™m writing the same Kubernetes specs: ConfigMap, Secret, Volume, Deployment, Service.Iâ€™m actively looking into ways to streamline this process, whether through text editor extensions, templating, or other tools. If you have tools that you use to help write and manage YAML, comment down below!Â â¬‡ï¸âœ¨ deployingWe have our YAML files. Now we can deploy the resources! Given my souped-up kubectl environment, itâ€™s tempting to do this manually.But this can be a struggle road, dragging you into the same docker build, docker push, kubectl apply, andkubectl delete pod commands. NoÂ fun.A tool called skaffold can automate away much of this pain. skaffold is magical: it watches your codebase for changes. When you save changes locally, skaffold will automatically docker build, push a new image tag, and redeploy into yourÂ cluster.One really cool thing skaffold does is auto-generate image tags. So in your actual YAML, you just list the image repo, not the tag, and skaffold will populate the new tag(s) onÂ deploy.spec:  containers:  - name: helloworld    image:  gcr.io/megangcp/helloworld    imagePullPolicy: Always   ports:     - containerPort: 8080All that skaffold needs is a (yes, YAML) configuration file:apiVersion: skaffold/v1beta3kind: Configbuild:  artifacts:  - image: gcr.io/megangcp/helloworlddeploy:  kubectl:    manifests:      - kubernetes/*This is a minimal config where I specify my image repo (in this case, in Google Container Registry, but any image registry like DockerHub also works). I also specify directory where my manifests live.skaffold is highly customizable, and can work with deploy tools like Helm in addition toÂ kubectl.ğŸ³ inspecting dockerÂ imagesskaffold abstracts the docker build process, but sometimes I want to look into my newly-built images to inspect things like: what is the image size compared to previous versions? what are the contents of each of my imageÂ layers?dive is an amazing tool for inspecting DockerÂ images.With dive, I can examine filesystem changes between different layers. This is super helpful if something in my Docker build has goneÂ wrong.ğŸ˜± debuggingNow weâ€™ve got pods running Kubernetes. WhatÂ next?Every so often (read: all the time) something goes wrongâ€Šâ€”â€Šwith my spec, or with my application code.My kubernetes debugging workflow isÂ usually:Describe the pod (kdpo alias). Is it my specâ€™s fault? (example: is the Deployment trying to mount a Secret I accidentally put in a different Namespace?) IfÂ notâ€¦Get the pod logs. the skaffold dev command will combine all the logs for every container deployed and stream all of it to stdout. But Iâ€™ve found that when I have two or more pods running, that format gets noisy. At the same time, the usual kubectl logs command can result in an endless cycle of copy-pasting new podÂ names.stern is a great alternative for tailing logs in a more customizable way. stern uses regular expressions to select on podsâ€Šâ€”â€Šand given that all pods start with their deployment name, you can follow logs for all the pods in a deployment, without having to know the exact pod name. SuperÂ helpful:If the logs arenâ€™t giving me clues for whatâ€™s gone wrong, usuallyÂ Iâ€™llâ€¦3. Exec into the pod (kex alias with tab completion):thatâ€™s aÂ wrapKubernetes is a big, complex piece of software with a large configuration model. I hope sharing some of these tools might help you, wherever youâ€™re at in your k8sÂ journey.Hereâ€™s the full list of tools and plugins mentioned in thisÂ post:iterm2 / palenight / oh-my-zshkubectl tab completionkubectxkubectl aliaseskrewVSCode withÂ GitLensskaffolddivesternâœ¨ Thanks for reading!Â âœ¨
