
== Article 1
* Title: 'One Year in Cloud Developer Relations'
* Author: 'Megan O’Keefe'
* URL: 'https://medium.com/@askmeegs/one-year-in-devrel-21b516fdaa05?source=rss-db638f78c20f------2'
* PublicationDate: 'Tue, 03 Sep 2019 14:57:09 GMT'
* Categories: developer-relations, google-cloud-platform, developer, software-engineering, career-advice

Last August, I moved from Software Engineering to a role in Developer Relations at Google Cloud. Since then, I have helped users adopt technologies like Istio, moved across the country (twice), spoken at multiple conferences, turned twenty-five, and became my team’s tech lead.at Google Cloud NEXT ‘19It’s been a fun, challenging year. Here are four lessons I’ve learned along the way.1) Willingness to learn &gt; everything else.When I started in this role, I was worried that I didn’t have enough experience. I had only been a “real” software engineer for two years, and at Google, I was immediately surrounded by smart, qualified people, many with years of experience. I felt like I had an impossible amount to learn in order to catch up.sourceBut here’s the thing. You don’t have to know everything about a certain technology or product in order to do effective DevRel. Developer Relations is about empathy — listening to users — and then forwarding their feedback to product teams. It’s also about creating content, whether that’s building new tools or samples, writing a tutorial, running an empathy session, or giving a talk. So usually, by the time you’re creating content, you’ve already built up expertise about the product or feature in question.In my case, listening to why customers were interested in Istio, and the successes and challenges they had adopting it, was one of the best ways to learn about the project. I learned quickly what a service mesh was for, and in the process of reading the docs, had fresh eyes for where gaps existed in the product.I think that for DevRel, more important than having a brain full of knowledge is a readiness to learn from users. The tech industry can change quickly, and you might do DevRel for many products over time. I don’t think you need many years of experience to create impactful content. But I think you do have to invest the time to continuously pick up new technologies.sourceStill, there will always be questions you can’t answer — how does Firestore work with Kubernetes? What is SOAP?? — and for those questions, I can turn to one of my awesome colleagues. Almost always, they can point me in the right direction. Which brings me to:2) People matter.DevRel can sometimes feel solitary. Because there are a lot of users to hear from, those connections can be short-lived. There is a not-insignificant amount of travel, and often, my teammates and I are working on different projects, with different teams.I think the nature of DevRel raises the stakes on the people you work with. Why? Because I think that in order to feel supported at work, you need a safe place to land: places where you can share triumphs and struggles, ask for feedback, engage in off-topic discussions about baking.And these relationships can go two ways: you can TA your teammates’ workshops, summarize articles for a group chat, help other DevRellers practice their talks, answer their questions (What’s a PVC??). I have been lucky to have multiple mentors since joining Google, who encouraged me to start communicating feedback to product teams within a few weeks of my start date. I am so grateful for them, and for the confidence they helped me build early on.sourceIn DevRel, there are also lots of other people, internally, to talk to. For me, this means the partner teams for the Google products I represent externally. This includes product managers, engineers, tech writers, marketing. These are the people I usually talk to most during any given weekday. For this reason, it matters a lot to work with a product team that is receptive to your feedback, interested in DevRel’s help, willing to answer questions, willing to invite you to customer meetings, and excited about improving their product.3) Your calendar is not your friend.When I moved into this role from Software Engineering, the most drastic difference in my working life was not the programming languages I used, or the products I worked with. It was meetings.On an average weekday, I have 6–8 meetings: with users, the open-source community, product managers, engineering leads, UX researchers, and my own team within DevRel.I’m an introvert, so meetings drain my battery, even if in a good way, and they can also disrupt uninterrupted time to write code, create new content, and otherwise think deeply about things. This means that I have to protect my time.sourceBecause I sit on the east coast and most of my colleagues are out west, I usually have a few quiet hours in the morning to get things done. But I certainly have not mastered time management for DevRel; I find it especially challenging to decline meetings with people I’m actively working with. I don’t want to let them down, or make it look like I don’t care! If you have advice about this, do comment down below.4) Work-life balance gets tougher.DevRel is a people job. My job is not to sell products, or to build them. It’s to connect people to Google’s technology, hear from them about how they’re using it, what they don’t like, and then to make things better. This means that often, you might hear more about the “bad” than the “good.” I think this can lead to a mindset of obligation to fix all the things. Especially true if the total DevRel footprint for a certain product is small.Also, there will probably be an endless backlog of things to do. There will be features to champion, bugs to file, docs to review, tweets to compose. All of this, coupled with the fact that I really like my job, makes work-life balance much harder than it was when I was a Software Engineer.sourceThe best strategy I’ve learned to cope with this is pretty simple, which is to leave work at the office as much as possible, not have anything work-related on my phone, and use my weekends to actively spend time with friends and family, do fun things, and sleep. Sleep is important. But again, I haven’t totally figured this out. Actually this is the thing I definitely have not figured out.Working in Developer Relations has helped me grow in many ways, and I’m grateful to all my colleagues for making my first year a great one.That said, no job is perfect. There are tradeoffs. I’m definitely writing less code than before. But every day, I get to flex a different set of muscles — writing code, writing prose, trying out products, active listening, engaging a customer, debugging bad YAML, public speaking. For me, at this stage in my career, DevRel is the right place for me to be, and I can’t wait to see what the next year has in store.sourceNote: This post also appears on my personal blog.

== Article 2
* Title: 'Building My Own Notes App (Glitch, Kubernetes)'
* Author: 'Megan O’Keefe'
* URL: 'https://medium.com/@askmeegs/building-my-own-notes-app-glitch-kubernetes-bdd340af46c7?source=rss-db638f78c20f------2'
* PublicationDate: 'Tue, 21 May 2019 17:01:47 GMT'
* Categories: kubernetes, firestore, web-development, golang, glitch

TLDR: Code is here (frontend) and here (backend).I’ve used lots of notes apps. Simplenote. nvALT. Bear. Apple Notes. And they’ve worked well enough. But lately I’ve been looking for two things:A programmatic way to read/write notes (API)A way to see a random note from the past (for inspiration)Right now, I’m using Apple Notes across all my devices, which is locked down re: programmatic access. So I knew it was time for a change. To take a first stab at the problem, I wrote my own private notes server, with an accompanying frontend.DesignMy requirements were minimal:Create + view notes. (And notes can be immutable; no need to edit.)View a random noteHTTPS everywhere. Also, the frontend must be locked down with a login screen.Here is where I landed:Notes App Architecture💻 FrontendI chose to use Glitch to create (and host) my notes frontend. I’ve heard great things about Glitch — it’s a community of developers/apps, but also way to create free, fully-hosted web apps without having to deal with npm, etc. on my own machine. I think my use case (a “hacking on the web” / side-project sort of app) was a great fit for Glitch, and I’d definitely recommend it.My JavaScript is rusty, so writing the frontend took the most time out of this whole process. (Code here.) For the server-side, I settled on a set of express.js endpoints (node.js), rendered via pug.js. The express functions use axios.js to call the backend notes server.On the client-side, I used jQuery for my button listeners. I also used DataTables to add search (and sorting) to my list of notes:My favorite thing about writing the frontend was creating the Pug views. So simple! Here’s where I show a random note:div.one      if error         h4= error       if note         h1 a note from the past        div.one          p.randomText= note.note… Which renders to:Finally, the whole frontend is locked down with a login screen, which authenticates with the backend, and stores a JWT as a cookie. This cookie is used for all subsequent calls to the Backend…☸️ BackendI could have just had my Node.js backend call the database directly. But for more practice, I wrote a server backend in Golang (code here). Then, I deployed the backend to Kubernetes, beneath a domain name I had lying around.The backend is a dead-simple golang HTTP server that speaks JSON (I didn’t use any API frameworks or generators). For instance, the handler for getting all the notes looks like this:// GetNotesHandler gets all notesfunc GetNotesHandler(w http.ResponseWriter, r *http.Request) { w.Header().Set("Access-Control-Allow-Origin", "*") w.Header().Set("Content-Type", "application/json")if err := validateJwt(r); err != nil {  w.WriteHeader(http.StatusUnauthorized)  io.WriteString(w, err.Error())  return }notes, err := getNotesHelper() if err != nil {  w.WriteHeader(http.StatusInternalServerError)  io.WriteString(w, err.Error()) }output, _ := json.Marshal(notes)w.WriteHeader(http.StatusOK) io.WriteString(w, string(output))}All calls to the server must have a valid JWT, issued via the POST /loginendpoint.Then, I wrote a simple Dockerfile to containerize the server, then pushed it to my image repo (in Google Container Registry).Next, I knew I’d have to deploy this Docker container somewhere. I know Kubernetes, so I chose to deploy to GKE out of convenience. But Kubernetes was probably overkill for my use case (see: relevant tweet), because I’m the only user of my backend server, and I probably won’t generate a lot of requests.Using GKE, however, allowed me to set up Managed SSL certificates for my domain, using the Kubernetes Ingress resource, and a GCP static IP address. Meaning I could hit https://&lt;my-domain-name&gt; and reach my backend server. This came in handy when it came time to connect my Glitch frontend to the backend (Glitch doesn’t allow plain http calls.). The alternative, here, would be to use LetsEncrypt or another certificate authority for your domain.Finally, here’s my Kubernetes deployment YAML, which actually deploys the backend server container into my Kubernetes cluster:     containers:      - name: server        image:  gcr.io/notesdb/notes:v0.0.4        imagePullPolicy: Always        ports:        - containerPort: 8080        volumeMounts:        - name: firestore-key          mountPath: /var/secrets/googleWhat’s that /var/secrets/google? It’s a mounted-in Kubernetes secret, which I added to my cluster ahead of time. This secret contains the credentials needed to talk to the database…📝 DatabaseMy notes have to live somewhere, so for a database I chose Firestore, which is Google Cloud’s newer NoSQL database for web and mobile. I chose Firestore mostly because I’d never tried it before; I could have also used Google Cloud Datastore or some other NoSQL database.The DB itself lives in the same Google Cloud project as my Kubernetes cluster, and it’s a single collection with a bunch of documents. Each document represents one Note.My backend code uses the Firestore client library for Golang. This was really easy to use — you just need a service account key, and you can start writing documents to your collection, like this:n := Note{  Timestamp: time.Now().Format(time.RFC3339),  Note:      note.Note, }_, _, err = client.Collection("notes").Add(context.Background(), n)That’s a wrap!This was a fun weekend project. And while there’s a lot I want to improve (a better mobile UX, render embedded links in the frontend), I’m happy with my app so far.✨ Thanks for reading!This post originally appeared at https://askmeegs.dev/posts/notes-project/ .

== Article 3
* Title: 'A Kubernetes Development Workflow for MacOS '
* Author: 'Megan O’Keefe'
* URL: 'https://medium.com/@askmeegs/a-kubernetes-development-workflow-for-macos-8c41669a4518?source=rss-db638f78c20f------2'
* PublicationDate: 'Thu, 24 Jan 2019 17:05:48 GMT'
* Categories: docker, macos, kubernetes, kubectl, containers

💻 A Kubernetes Developer Workflow for MacOSKubernetes development is not one-size-fits-all. Maybe you’re learning Kubernetes with Minikube on your local machine; maybe you’re part of a large organization with many clusters; maybe your cluster is an on-prem lab, or lives in the cloud.But whether you’re a cluster operator managing policies, an app developer test-driving a new service, or a data scientist running Kubeflow, chances are you are doing some (or all) of: connecting to a cluster, inspecting its state, creating resources, and debugging those resources.As a developer relations engineer for Kubernetes, I work a lot with demo code, samples, and sandbox clusters. This can get interesting to keep track of (read: total chaos). So in this post I’ll show some of the tools that make my Kubernetes life a lot better.This environment can work no matter what flavor of Kubernetes you’re running, and all these tools are made possible by the amazing open source community.💻 terminalI use iterm2 with the palenight color scheme. On top of that, I’m running zsh and oh_my_zsh with the default robby-russell theme.This theme has basic Git support but is otherwise minimal. If you’re interested in displaying your current Kubernetes context in your shell prompt, check out kube-ps1 or the spaceship prompt.Second, my ~/.zshrc file has an essential line:source &lt;(kubectl completion zsh)This enables tab completion for kubectl commands. No more copy-pasting pod names!🛶 navigating clustersOn any given day, I might switch between three clusters. This might describe you too! Do you get annoyed anytime you have to open your kubeconfig?Same! Luckily, there is kubectx for exactly this purpose:kubectxkubectx lets you navigate between cluster contexts easily. My favorite thing is running kubectx -, which takes you to the cluster you were using last.⚡️ superpowered kubectlNow that we’ve got a cluster to work with, let’s do stuff.Maybe you’ve felt that kubectl commands can get very long, with lots of command-line flags. I have found that kubectl tab completion, plus a comprehensive set of aliases (command shortcuts), helps a lot.Here is a great list of kubectl aliases, that lets you run things like:get podsdescribe podFinally, I use a few kubectl plugins. But manually setting these up can get annoying. So I use krew, an open-source plugin manager for kubectl:krewkrew lets you browse, install, and use kubectl plugins, so that you can run custom commands.📜 wrangling yamlNow that we have a cluster ready to go, let’s deploy something.Developing on Kubernetes means writing, managing, updating, and deploying lots of YAML files. I keep all my YAML files in Git. Adopting GitOps early (rather than keeping files locally) lets me see revision history as I’m doing early debugging, and sets me up for success later if/when I start formalizing a pipeline for the application I’m working on. (example: a Github webhook for a CI/CD pipeline.)I use VSCode as my text editor, plus the Moonlight theme. And while VSCode has a ton of great features on its own, Red Hat’s YAML Support plugin is very handy for validation, autocompletion, and formatting.Right now my process of writing Kubernetes YAML is fairly manual. But usually for every new project, I’m writing the same Kubernetes specs: ConfigMap, Secret, Volume, Deployment, Service.I’m actively looking into ways to streamline this process, whether through text editor extensions, templating, or other tools. If you have tools that you use to help write and manage YAML, comment down below! ⬇️✨ deployingWe have our YAML files. Now we can deploy the resources! Given my souped-up kubectl environment, it’s tempting to do this manually.But this can be a struggle road, dragging you into the same docker build, docker push, kubectl apply, andkubectl delete pod commands. No fun.A tool called skaffold can automate away much of this pain. skaffold is magical: it watches your codebase for changes. When you save changes locally, skaffold will automatically docker build, push a new image tag, and redeploy into your cluster.One really cool thing skaffold does is auto-generate image tags. So in your actual YAML, you just list the image repo, not the tag, and skaffold will populate the new tag(s) on deploy.spec:  containers:  - name: helloworld    image:  gcr.io/megangcp/helloworld    imagePullPolicy: Always   ports:     - containerPort: 8080All that skaffold needs is a (yes, YAML) configuration file:apiVersion: skaffold/v1beta3kind: Configbuild:  artifacts:  - image: gcr.io/megangcp/helloworlddeploy:  kubectl:    manifests:      - kubernetes/*This is a minimal config where I specify my image repo (in this case, in Google Container Registry, but any image registry like DockerHub also works). I also specify directory where my manifests live.skaffold is highly customizable, and can work with deploy tools like Helm in addition to kubectl.🐳 inspecting docker imagesskaffold abstracts the docker build process, but sometimes I want to look into my newly-built images to inspect things like: what is the image size compared to previous versions? what are the contents of each of my image layers?dive is an amazing tool for inspecting Docker images.With dive, I can examine filesystem changes between different layers. This is super helpful if something in my Docker build has gone wrong.😱 debuggingNow we’ve got pods running Kubernetes. What next?Every so often (read: all the time) something goes wrong — with my spec, or with my application code.My kubernetes debugging workflow is usually:Describe the pod (kdpo alias). Is it my spec’s fault? (example: is the Deployment trying to mount a Secret I accidentally put in a different Namespace?) If not…Get the pod logs. the skaffold dev command will combine all the logs for every container deployed and stream all of it to stdout. But I’ve found that when I have two or more pods running, that format gets noisy. At the same time, the usual kubectl logs command can result in an endless cycle of copy-pasting new pod names.stern is a great alternative for tailing logs in a more customizable way. stern uses regular expressions to select on pods — and given that all pods start with their deployment name, you can follow logs for all the pods in a deployment, without having to know the exact pod name. Super helpful:If the logs aren’t giving me clues for what’s gone wrong, usually I’ll…3. Exec into the pod (kex alias with tab completion):that’s a wrapKubernetes is a big, complex piece of software with a large configuration model. I hope sharing some of these tools might help you, wherever you’re at in your k8s journey.Here’s the full list of tools and plugins mentioned in this post:iterm2 / palenight / oh-my-zshkubectl tab completionkubectxkubectl aliaseskrewVSCode with GitLensskaffolddivestern✨ Thanks for reading! ✨
