<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Stories by Kaz Sato on Medium]]></title>
        <description><![CDATA[Stories by Kaz Sato on Medium]]></description>
        <link>https://medium.com/@kazunori279?source=rss-4b21e207ea2c------2</link>
        <image>
            <url>https://cdn-images-1.medium.com/fit/c/150/150/0*88n0-h2Uc99SrEHq.jpeg</url>
            <title>Stories by Kaz Sato on Medium</title>
            <link>https://medium.com/@kazunori279?source=rss-4b21e207ea2c------2</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Thu, 04 Jul 2024 15:30:00 GMT</lastBuildDate>
        <atom:link href="https://medium.com/@kazunori279/feed" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[AutoML Vision と RasPi でリビングのいろいろな音を認識する]]></title>
            <link>https://medium.com/@kazunori279/automl-vision-%E3%81%A8-raspi-%E3%81%A7%E3%83%AA%E3%83%93%E3%83%B3%E3%82%B0%E3%81%AE%E3%81%84%E3%82%8D%E3%81%84%E3%82%8D%E3%81%AA%E9%9F%B3%E3%82%92%E8%AA%8D%E8%AD%98%E3%81%99%E3%82%8B-a9d5d6a1a1b9?source=rss-4b21e207ea2c------2</link>
            <guid isPermaLink="false">https://medium.com/p/a9d5d6a1a1b9</guid>
            <category><![CDATA[machine-learning]]></category>
            <category><![CDATA[iot]]></category>
            <category><![CDATA[google-cloud-platform]]></category>
            <dc:creator><![CDATA[Kaz Sato]]></dc:creator>
            <pubDate>Tue, 08 Jan 2019 23:03:32 GMT</pubDate>
            <atom:updated>2019-01-08T23:40:29.820Z</atom:updated>
            <content:encoded><![CDATA[<p>#raspi #おうちIoT #お手軽ML #gcpja</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DKyY62Phip3z_UHljCCRmA.png" /></figure><p><a href="https://cloud.google.com/automl/?hl=ja">Cloud AutoML Vision</a> は、<a href="https://www.apps-gcp.com/cloud-automl-vision/">画像とその分類ラベルをクラウドにアップロードするだけ</a>で画像認識の機械学習モデルを作成できるサービス。<a href="https://cloudplatform-jp.googleblog.com/2018/03/automl-vision-in-action-from-ramen-to-branded-goods.html">ラーメン二郎のどんぶり画像から 95% 精度で店舗を当てたり</a>できる高性能だけど、機械学習のディープな知識や経験がなくても使える。</p><p>で、これでまず試してみたかったのが、音の認識だ。画像じゃなくて音。</p><p>2 年くらい前に、画像認識用の CNN を使って音声を認識する<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/CNN_ASLPTrans2-14.pdf">論文</a>が Microsoft Research から出てて、へぇーっと思った。<a href="https://ja.m.wikipedia.org/wiki/%E3%82%B9%E3%83%9A%E3%82%AF%E3%83%88%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0">スペクトログラム</a>っていう、よく犯罪捜査で出てくる声紋のアレを使って音を画像にして、その模様から音の特徴を認識する。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/650/1*Qi_iyAEeDEdxlUiUSWn_Zw.png" /><figcaption>CNN で音声認識（Microsoft Research）</figcaption></figure><p>なるほどなあ。。つまり、世の中のどんなデータでも、<strong>捉えたい特徴を画像の特徴として表せれば、画像認識で識別できる</strong>……ってことだ。</p><p>そして、AutoML Vision で高精度の画像認識モデルを作れるということは、スペクトログラムによる音認識も、自分で TensorFlow で CNN いじったりしなくても簡単に試せるのか。まじか。と思った。</p><p>そこで、年末年始のヒマな時間を使って試してみたら、4 日くらいでこんなのができた。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FMfNt8EfDmTY%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DMfNt8EfDmTY&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FMfNt8EfDmTY%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/9b76ccb532b6d2e9e9a576f2175f5de4/href">https://medium.com/media/9b76ccb532b6d2e9e9a576f2175f5de4/href</a></iframe><p>リビングで聴こえるいろんな音を RasPi のマイクで拾い、その種類を認識する。来客ベル、電子レンジの終了チャイム、人の声、キッチンで何かしてる音、くしゃみやせき、鼻をかむ、掃除機、ドアの閉まる音、その他、の 9 種類を検知できた。</p><p>これは何に使えるか。例えば、</p><ul><li>お風呂が沸いた・ご飯が炊けた・来客ベルが鳴ったことを、<a href="https://ifttt.com/line">IFTTT 経由の LINE 通知</a>や <a href="https://qiita.com/azipinsyan/items/db4606aaa51426ac8dac">Google Home の push 通知</a>（非公式）でお知らせ</li><li>リビングで誰かがしゃべったり、掃除機かけたりといった生活行動を検知。Google Sheet でライフログ集めたり Nature Remo や Switchbot で家電を動かす</li><li>くしゃみ・せき・鼻をかむ音の回数が多くなったらスマートスピーカーが「もしかしてカゼですか？ あったかくしてくださいね」と気づかい、加湿器が動き出し、アマゾンで勝手に薬を発注する</li></ul><p>ってあたりが思いつく（それぞれ実利的かはおいといて）。リビングだけじゃなくて、オフィスや野外など、音が拾える場所ならどこでも使える。</p><p>開発に必要なものは、 RasPi と USB マイク。学習に使う AutoML Vision は、そこそこの精度でいいなら無償枠で十分。5 万円かけてじっくり学習すれば、もっと精度の高いモデルができる。これを、ML 専門家でなくてもさくっと作れるのがいいところ。</p><p>以下、この音認識ガジェットを作るためのおおまかな手順を紹介したい。今回は bash スクリプトですべて済ませた。コードは<a href="https://github.com/kazunori279/raspi/tree/master/mlsd">ここ</a>。</p><h4>RasPi3 で録音の設定</h4><p>まずは RasPi3 に USB マイクをつなげて録音する準備。<a href="http://shokai.org/blog/archives/7914">この記事</a>を参考に、arecord と sox が動くことを確認。いろいろ試したのち、arecord はこんな設定で落ち着いた。</p><pre>arecord --max-file-time 1 —-use-strftime raw_%Y%m%d-%H%M%S.wav \<br>  -q -c 1 -D plughw:1,0 -r 16000 -f S32_LE &amp;</pre><ul><li>-f S32_LE ：32 bit little endian の wav ファイルで保存</li><li>-q ：いろいろ細かいメッセージは出さない</li><li>-c 1 ：チャンネル数は 1（モノラル）</li><li>-r 16000：サンプリングレート 16 kHz で録音</li><li>-D plughw:1,0：lsusb で確認した USB マイクのカード番号 0 とサブデバイス番号 1</li><li>--max-file-time 1 ：wav ファイルを 1 秒ごとに保存</li><li>--use-strftime：wav ファイル名のフォーマットを指定（例：raw_20190101–120000.wav）</li></ul><p>これで、 ctrl-c で止めるまでずっと録音されっぱなしになり、1 秒ごとに wav ファイルが、</p><pre>raw_20190101-120000.wav<br>raw_20190101-120001.wav<br>raw_20190101-120002.wav<br>...</pre><p>って感じに保存される。</p><h4>音が鳴ったら切り出す</h4><p>ここからは、<a href="http://sox.sourceforge.net/">sox</a> で音を加工するbash スクリプトを書いていく。sox は音を切ったり貼ったりたいていの音加工はなんでもできるスゴいツールだ。</p><p>arecord から出てくる細切れの wav ファイルから、ある程度の音量の音だけを切り出したい。まずは 2 秒分をひとつの wav にマージ。</p><pre>sox ＜マージするファイル名のリスト＞ ＜保存ファイル名＞</pre><p>これで 2 秒間の wav ファイルができる。つぎに、<a href="https://digitalcardboard.com/blog/2009/08/25/the-sox-of-silence/">この記事</a>を参考に sox の silence フィルタを使って無音部分をカット。</p><pre>sox ＜元ファイル名＞ ＜保存ファイル名＞ silence 1 0.1 3%</pre><p>音量 3% 以上の音が 0.1 秒以上続いたところから後を保存する。</p><p>ここで、1 秒間に満たないファイルができた場合は削除して処理終了。1 秒以上のファイルになった場合は、冒頭の 1 秒間だけを取り出す。</p><pre>sox ＜元ファイル名＞ ＜保存ファイル名＞ trim 0 1</pre><p>これで、「何かの音が鳴ったらそこだけ切り取って 1 秒間の wav ファイルにするスクリプト」ができた。1 秒間って長さは適当である。いずれにせよ、長さがバラバラよりも揃えておいた方が認識しやすいだろうなと思った。</p><p>この bash スクリプトを半日くらい動かしたら、2700 個の wav ファイルが貯まった。例えばこんな音。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fw.soundcloud.com%2Fplayer%2F%3Furl%3Dhttps%253A%252F%252Fapi.soundcloud.com%252Ftracks%252F554862708%26show_artwork%3Dtrue&amp;url=https%3A%2F%2Fsoundcloud.com%2Fkazunori-sato%2F20190103-182501-out&amp;image=http%3A%2F%2Fa1.sndcdn.com%2Fimages%2Ffb_placeholder.png%3F1546447442&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=soundcloud" width="800" height="166" frameborder="0" scrolling="no"><a href="https://medium.com/media/ae46bb0ee2d587496a56bbad5153054e/href">https://medium.com/media/ae46bb0ee2d587496a56bbad5153054e/href</a></iframe><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fw.soundcloud.com%2Fplayer%2F%3Furl%3Dhttps%253A%252F%252Fapi.soundcloud.com%252Ftracks%252F554864100%26show_artwork%3Dtrue&amp;url=https%3A%2F%2Fsoundcloud.com%2Fkazunori-sato%2F20190103-122727-out&amp;image=http%3A%2F%2Fa1.sndcdn.com%2Fimages%2Ffb_placeholder.png%3F1546447442&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=soundcloud" width="800" height="166" frameborder="0" scrolling="no"><a href="https://medium.com/media/dcd249d9454a3004223f8ba5e711b3a6/href">https://medium.com/media/dcd249d9454a3004223f8ba5e711b3a6/href</a></iframe><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fw.soundcloud.com%2Fplayer%2F%3Furl%3Dhttps%253A%252F%252Fapi.soundcloud.com%252Ftracks%252F554864679%26show_artwork%3Dtrue&amp;url=https%3A%2F%2Fsoundcloud.com%2Fkazunori-sato%2Fkitchen&amp;image=http%3A%2F%2Fa1.sndcdn.com%2Fimages%2Ffb_placeholder.png%3F1546447442&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=soundcloud" width="800" height="166" frameborder="0" scrolling="no"><a href="https://medium.com/media/8ea4004de70f1d50bc9419a75cf3b258/href">https://medium.com/media/8ea4004de70f1d50bc9419a75cf3b258/href</a></iframe><h4>音のラベル付け</h4><p>この音にラベルを付けてくためのスクリプトを書いた。wav ファイルをひとつずつ再生して、ラベルを手入力する。</p><pre>$ ./label.sh<br>Label for 20190107-094321_out.wav (r: replay, d: delete): r<br>Label for 20190107-094321_out.wav (r: replay, d: delete): bell<br>Label for 20190107-094322_out.wav (r: replay, d: delete): bell</pre><p>実際にラベル付けする時には、ひとつ前の音と同じラベルを入れることが多い。なので、ひとつ前のラベルをデフォルト値として出し、あとは改行だけでぽんぽんラベル付けできるようにした。ラベル付けにかかった時間は 1〜2 時間くらい。</p><p>ラベル付けといっても大したことはしてなくて、ラベルと同じ名前のディレクトリにファイルを移動してるだけ。今回はこんなラベルを付けたけど、用途に応じて好きなラベルを定義すればよい。</p><ul><li>0：その他</li><li>kitchen：キッチンで何かやってる音</li><li>voice：しゃべり声</li><li>door：ドアが閉まる音</li><li>bell：来客ベル</li><li>blow：鼻をかむ音</li><li>cough：せきとくしゃみ</li><li>cleaner：掃除機</li><li>microwave：電子レンジのできましたチャイム</li></ul><p>「お風呂が沸きました」や「ご飯が炊けました」の認識も試したかったけど、どちらも一日一回しか鳴らないので音をたくさん集めるのが難しく、まだやってない。</p><h4>音の data augmentation</h4><p>2,700 個の音が集まったけど、学習するには数が少ないなと思ったので、data augmentation すなわち<a href="https://products.sint.co.jp/aisia/blog/vol1-7">学習データの水増しの方法</a>を考えた。</p><p>画像認識の場合は、元画像に対して回転・移動・変形・ノイズ追加・白色化など、いろいろ適用して数十倍に増やすやり方がよく使われ、 Keras 等ではそうした data augmentation 機能が簡単に呼び出せる。でも、音認識の場合はどうするんだろう。。とググったら、いくつか論文やライブラリが出てきた。音程を変えたり、ノイズを加えたり、いくつかのやり方が見つかった。</p><p>しかし今回の用途では音源もマイクも変化しないので、音程を変えたりノイズ入れたりしてもあんまり意味なさそう。なので、今回は音に normalization をかける方法だけ使った。これは小さい音も大きな音も一定の音量になるよう揃える加工である。sox の norm フィルタを使い、</p><pre>for ((i=-7; i != -2; i++));<br>  sox --norm=$i ＜元ファイル名＞ ＜保存ファイル名＞<br>done</pre><p>ってループを書いて、-7 dB から -3 dB まで、それぞれの音量に normalize された 5 つの wav ファイルを作った。つまり 5 倍の水増しで、合計 13,500 個になった。</p><p>この data augmentation が認識精度にどれだけ貢献しているのか……果たして他のフィルタの方がよいのか……めんどくさくて検証してないからわからない。俺たちは雰囲気で ML をやっている。</p><h4>スペクトログラム画像を作る</h4><p>学習データ作成の仕上げ。こんなふうにしてスペクトログラム画像を作る。sox なんでもできるな。</p><pre>sox ＜元ファイル名＞ -c 1 -n rate 16k spectrogram -r -h -0 \<br>  ＜保存ファイル名＞</pre><ul><li>-c 1：チャンネル数は 1（モノラル）</li><li>-n：これ何だっけ。。</li><li>rate 16k：16 kHz 音声データとして読む</li><li>spectrogram：スペクトログラム画像を生成</li><li>-r：デフォルトで画像内に追加される凡例を削除</li><li>-h：色の派手な high-color 配色を使用。こっちの方が音の特徴が出るらしい</li><li>-o：png ファイル名を指定</li></ul><p>ここまで、2,700 個の wav ファイルに対して normalization による水増しとスペクトログラム生成を RasPi3 上で実行すると、1〜2 時間くらいかかる。終わると、こんな画像ができる。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/400/1*_Wqxyegh9-A2LhrYkD_URQ.png" /><figcaption>ドアが閉まる音</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/400/1*TwroO8WqqYN4pOn_7MZEuw.png" /><figcaption>電子レンジの終了チャイム</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/400/1*FNqLCqGTZBa8-RRCgcGqTQ.png" /><figcaption>キッチンで何かしてる音</figcaption></figure><p>これを人の目で「この音！」と見分けるのは難しい。電子レンジの音は特徴的な横線が入っててわかりやすいけど。AutoML Vision で見分けられるかやってみる。</p><h4>AutoML Vision にアップロード</h4><p>AutoML Vision を初めて使うときの手順は<a href="https://cloud.google.com/vision/automl/docs/quickstart?hl=ja">ここ</a>で説明されているので省略。スペクトログラム画像を AutoML Vision にアップロードして学習を行うのだけど、その方法は 2 つある。</p><ul><li>zip にまとめてブラウザからアップロードする（画像ファイルを収めたディレクトリ名がラベルとして認識される）</li><li>Google Cloud Storage に画像ファイルをアップロードしておいて、そのURI とラベルを並べた CSV ファイルをアップロードする</li></ul><p>今回はスペクトログラム画像が 13,500 枚、1.9 GB ぶんある。なんとかブラウザからアップロードできる大きさなので、てっとり早く前者の zip ファイル方式を選んだ。</p><p>アップロードが終わると、AutoML Vision のダッシュボードに以下のようにサムネと読み込み件数が表示される。重複した画像は自動的に取り除かれるので、件数がすこし減っている。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DGihAqYTTlqpwq0eXNkJaA.png" /><figcaption>AutoML Vision に画像をアップロードしたところ</figcaption></figure><p>各ラベルの件数も比較できる。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pu1c3vGRNSieZvHHuXA_tA.png" /><figcaption>ラベルごとの画像枚数</figcaption></figure><p>普通に日常生活をしながら音を集めてると、どうしても偏ってしまう。そして後ほど実際に試してわかったけど、やはり集めた数の少ない音は認識精度も低くなる。なので、上記件数のうち bell や door は繰り返し録音して件数を増やしたものだ。ドアをなんどもバタンバタンしたり。</p><p>繰り返し録音できない音はちょっときびしそうだ…… USB マイクをいくつもつなげて同時録音するしかないかな。また、data augmentation をもうちょっと工夫して、多すぎる音を間引いたり少なすぎる音を水増ししたりすれば、より精度が向上するかもしれない。</p><h4>AutoML Vision で学習</h4><p>学習用の画像とラベルが正しく読み込まれたことを確認したら、TRAIN タブをクリックして学習を開始。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*C9rQ7iyEb37g3J4lIKULUA.png" /><figcaption>学習のご予算を選ぶ</figcaption></figure><p>ここで 2 つの選択肢があって、</p><ul><li>1 compute hour：15分〜数時間で終わるお手軽モード。精度はそこそこ。毎月 10 回まで無償</li><li>24 compute hour：24 時間かけて学習する Google の本気モード。<a href="https://ai.googleblog.com/2017/11/automl-for-large-scale-image.html">学習データにぴったりな ML モデルを ML が自動作成</a>する仕組みで、ML エキスパートがじっくり時間をかけてカスタマイズしたような精度が出る。1 回あたりおよそ 5 万円かかる（2019 年 1 月現在。料金表は<a href="https://cloud.google.com/vision/automl/pricing">ここ</a>）</li></ul><p>とりあえずは前者の 1 compute hour を試してみる。小一時間で学習が終わるので、EVALUATE タブでモデルの精度を確認できる。こんな結果が出た。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*_0rSxvOd1fPsS3MP_vFUSQ.png" /><figcaption>AutoML Vision による音の予測結果（predicted label）と正解（true label）を比べた表</figcaption></figure><p>これは混同行列っていう表で、AutoML Vision による音の認識テスト結果（predicted label）と正解（true label）を比べたもの。青いところがラベルごとの精度を表していて、お手軽モードにしてはわるくない。スペクトログラム画像で音の認識ってほんとにできるんだな、と思った。</p><p>cleaner や bell なんかは高精度が出てるけど、cough と microwave はサンプルの少なさもあってあんまりいい精度が出ていない。ちなみにモデル全体の precision（適合率：認識が正しい割合）は 95.2%、recall（再現率：認識できた割合）は 76.4% であった。つまり、音が鳴ったとき検知できるのは 7〜8 割くらい。もうちょっと精度がほしい。</p><p>で、Google の本気モードである 24 compute hours を試してみた。こんな精度。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*AcsGu_JxU2ANlAwKesM0Jw.png" /></figure><p>高すぎる……。precision/recall も見てみよう。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gxdXB70Y9zjNKoZYUrijGQ.png" /></figure><p>precision は 99.8%で recall は 95.6%、ROC カーブはほぼ直角。これ過学習（モデルが答えを丸暗記してしまう現象）になってそう。この結果はこのまま鵜呑みにできないので、実際に音認識を試したときの精度を追って検証する。</p><h4>AutoML Vision の REST API を呼び出す</h4><p>モデルの学習が終わったら、AutoML Vision の REST API を呼び出すだけで、このモデルを使った画像認識（prediction）をすぐに行える。自分でサーバを立てて ML ライブラリやモデルを入れたりする必要はない。サーバレスって便利だ。</p><p>PREDICT タブを開くと、こんなふうに呼び出せば使えるよという例が表示される。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*lRI9248KRNsWtP71uSL9eg.png" /></figure><p>つまり、画像を base64 にエンコードして JSON に埋め込み、curl で POST すればよい。</p><p>といっても、これを実行するまえに認証の設定を済ませておく必要がある。詳しい説明が<a href="https://cloud.google.com/vision/automl/docs/using-the-api?hl=ja">このドキュメント</a>にあるけど、やるべきことは、</p><ul><li><a href="https://cloud.google.com/sdk/downloads?hl=ja#linux">Cloud SDK をインストール</a></li><li>API を呼び出す<a href="https://cloud.google.com/vision/docs/common/auth?hl=ja#set_up_a_service_account">サービスアカウント</a>を作成、キーファイルを RasPi に入れておく</li><li>サービスアカウントに AutoML の edit 権限を設定</li></ul><p>である。この準備ができたら、画像を base64 にしてリクエスト用の JSON ファイルに埋め込み、</p><pre>curl -s -X POST -H &quot;Content-Type: application/json&quot; \<br>  -H &quot;Authorization: Bearer `cat access_token`&quot; \<br>  https://automl.googleapis.com/v1beta1/projects/＜プロジェクトID＞/locations/us-central1/models/＜モデルID＞:predict \<br>  -d @api_request.json &gt; api_response.json</pre><p>として curl で API を呼び出す。今回はお手軽に済ませたのですべて bash スクリプトで 書いたけど、Python から API を呼び出すライブラリもある。REST API を呼び出して 3 秒ほどすると、認識結果のラベルとスコアが返ってくる。</p><pre>{<br>  &quot;payload&quot;: [<br>    {<br>      &quot;classification&quot;: {<br>        &quot;score&quot;: 0.8718641<br>      },<br>      &quot;displayName&quot;: &quot;kitchen&quot;<br>    }<br>  ]<br>}</pre><p>これらを見て、RasPi のディスプレイに絵を描くなり、IFTTT で家電連携するなりすればよい。スコアが低い場合（0.5 とか 0.6 とか）は認識結果があまり当てにならないのでスキップしといた方がよい。</p><p>これで音認識ガジェットのできあがり。</p><h4>音認識の精度とレイテンシとコスト</h4><p>できあがったガジェットで、実際の音認識の性能をいろいろ検証してみた。</p><ul><li><strong>実際の認識精度</strong>：実際にマイクを通してそれぞれの音を 10 回ずつ聞かせてみたところ、こんな結果になった。</li></ul><pre>声：100%<br>ドア：80%<br>せき：70%<br>来客ベル：100%<br>電子レンジ：100%<br>鼻をかむ：50%<br>キッチン：70%<br>掃除機：100%</pre><p>決まった音しか鳴らない電子レンジや掃除機、来客ベルは誤認識がほとんど起きない。これらの用途なら、今回の仕組みでそのまま実用になりそうだ。</p><p>一方、ひとつひとつの音が毎回異なるもの、例えば鼻をかむ、せき、キッチンの音は、7 割程度に落ちる。とくに鼻をかむ音は、集めた音の数が少ない（あんまり何度も意味なく鼻をかむ気になれない）せいか半分しか当たらなかった。AutoML Vision の画面上で精度がとても高くなったのは、おそらく過学習のせいだろう。これらの認識精度を上げるには、もっともっと音のサンプルを集める必要がある。</p><p>もうひとつ気づいたのは、複数の音が混ざると誤認識が多い点。これは data augmentation を工夫すれば改善するかもしれない。もとの音に対して、別の音や環境雑音をランダムに選んで小さな音でミックスする等。</p><ul><li><strong>認識のレイテンシ</strong>：上述のとおり、AutoML Vision の画像認識は、高精度な一方でレイテンシが高い。us-central1 リージョンで動いているせいもあるけど、curl で呼んでから答えが返るまでに 3 秒くらいかかるので、即時性が要求される用途にはあまり向かない。来客ベルを検知してお知らせしてる間にお客さん返っちゃう</li><li><strong>認識のコスト</strong>：AutoML Vision の画像認識は毎月 1,000 回までは無償で、その後は 1,000 回の認識あたり $3 かかる。一日 1,000 個の音が検出されるとして、一日あたりおよそ 300 円くらい。お手軽さと高精度を考えればこんなものだろうけど、たくさん音が検出される用途ではコストが気になりそう</li></ul><h4>まとめ</h4><p>冒頭で書いたように、この音認識ガジェットは正月休みの 4日間くらいで作れた。音の加工や data augmentation などの前処理は自分で工夫する必要があったけど、ML モデル開発でいちばんハードルの高い作業はスキップできる。つまり、いまどきのイケてるモデルを見つけて理解して TensorFlow で書いたり、 TF 学習環境を用意したり、ハイパラチューンしたり……これらはすべて AutoML まかせ。なので、ML のディープな知識と経験がなくても、precision/recall 等の精度の見方、検証方法や過学習の防ぎ方といった基本知識があれば扱える。</p><p>このお手軽 ML で、身の回りのいろんな問題を解いてみたいなと思った。音認識だけでなく、センサーデータや時系列データ、ビジネスデータ等々、いろいろなデータの特徴を画像として取り出し、 AutoML Vision に入れるとどうなるか。人がぱっと見てわからないような特徴もばっちり捉えられるのだから、へーこんなことも分かるのか！ って使い方がたくさん出てくるはず。</p><p>Disclaimer: この記事は個人的なものです｡ここで述べられていることは私の個人的な意見に基づくものであり､私の雇用者には関係はありません｡</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a9d5d6a1a1b9" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[obniz でつくる指紋認証ドアロック]]></title>
            <link>https://medium.com/@kazunori279/obniz-%E3%81%A7%E3%81%A4%E3%81%8F%E3%82%8B%E6%8C%87%E7%B4%8B%E8%AA%8D%E8%A8%BC%E3%83%89%E3%82%A2%E3%83%AD%E3%83%83%E3%82%AF-d5f14ab2297d?source=rss-4b21e207ea2c------2</link>
            <guid isPermaLink="false">https://medium.com/p/d5f14ab2297d</guid>
            <category><![CDATA[iot]]></category>
            <dc:creator><![CDATA[Kaz Sato]]></dc:creator>
            <pubDate>Thu, 03 Jan 2019 08:00:05 GMT</pubDate>
            <atom:updated>2019-02-20T06:33:31.179Z</atom:updated>
            <content:encoded><![CDATA[<p>#obniz #おうちIoT #MLなし</p><p>スマートロック <a href="https://qrio.me/smartlock/">Qrio Lock</a> を使っているのだけど、ドアの開け閉めのためにスマホを取り出してアプリ起動するのは面倒である。Qrio Lock にはお出かけから帰ると GPS と BLE で帰宅を検知してドアを自動解錠する機能があるけど、これ調子がよくない時はドアが開くまでしばらく待たされることがあって、いまいち使えない。</p><p>そこで、<a href="https://obniz.io/">obniz</a> で指紋認証部分を作り、Qrio Lock を解錠する仕組みを作ってみた。こんなふうに動く。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FP63h6YYb4fM%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DP63h6YYb4fM&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FP63h6YYb4fM%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/3302ddd0f4e5952c95f817a0cbfe466c/href">https://medium.com/media/3302ddd0f4e5952c95f817a0cbfe466c/href</a></iframe><p>obniz で指紋認証 → <a href="https://ifttt.com/">IFTTT</a> の Webhook 呼び出し → IFTTT から Switchbot 呼び出し → Switchbot で Qrio Key を押す → 解錠 という流れである。Switchbot で Qrio Key を押すってあたりにむりやり感あるし、なんだか全体的にコストかかり過ぎな気もするが、そこは気にしないのである。</p><p>コードは<a href="https://github.com/kazunori279/obniz_samples/tree/master/fingerprint_door_lock">ここ</a>。</p><h4>指紋スキャナをつなぐ</h4><p>まずは指紋スキャナを探した。<a href="https://www.switch-science.com/catalog/3757/">いい感じの製品</a>がスイッチサイエンスで売ってた。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FPPNoO5uaUhM%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DPPNoO5uaUhM&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FPPNoO5uaUhM%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/d3b50bd98374d3d0c95211c9a9174c33/href">https://medium.com/media/d3b50bd98374d3d0c95211c9a9174c33/href</a></iframe><p>4500 円くらい。200 個の指紋を登録できる。<a href="https://learn.sparkfun.com/tutorials/fingerprint-scanner-gt-521fxx-hookup-guide?_ga=2.145540660.1268932596.1546498189-361129422.1542760954">sparkfun のドキュメント</a>を見るとシリアル（UART）で制御できるようなので、obniz の <a href="https://obniz.io/doc/sdk/doc/uart">UART API</a> でつながるはず。</p><p>で、シリアルにどんなプロトコルを流せばよいか。メーカーが出してる<a href="https://cdn.sparkfun.com/assets/learn_tutorials/7/2/3/GT-521F52_Programming_guide_V10_20161001.pdf">プログラミングガイド</a>を見た。こんなバイト列を送ればよいらしい。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Y8Cu4IKQZoyl29Z9Oyz3qQ.png" /></figure><p>この Command code と Input parameter ってところに、指紋登録とか認識とかのコマンドやパラメータを入れればよい。</p><p>なんだか難しくなさそうなので、まずはこのコマンド送信のところを書いてみた。最初にUART API を初期化して、</p><pre>uart = obniz.getFreeUart();<br>uart.start({tx: UART_TX, rx: UART_RX, baud:9600, drive:&#39;3v&#39;});</pre><p>続いて送信するバイト列を little endian で組み立てる。</p><pre>  // start code and device id<br>  const mask = 0xff;<br>  var packet = [0x55, 0xaa, 0x01, 0x00]; <br>  <br>  // send the param<br>  packet.push(param &amp; mask);<br>  packet.push((param &gt;&gt; 8) &amp; mask);<br>  packet.push((param &gt;&gt; 16) &amp; mask);<br>  packet.push((param &gt;&gt; 24) &amp; mask);<br><br>  // send the command<br>  packet.push(command &amp; mask);<br>  packet.push((command &gt;&gt; 8) &amp; mask);<br>  <br>  // calc check sum<br>  var sum = getChecksum(packet);<br>  packet.push(sum &amp; mask);<br>  packet.push((sum &gt;&gt; 8) &amp; mask);</pre><p>最後に、このバイト列を UART で送る。</p><pre>uart.send(packet);</pre><p>すると、UART API のコールバック関数に、以下のフォーマットでレスポンスが返ってくる。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*GaCniF5GTq4JtVlKOA27Fw.png" /></figure><p>ここも、仕様どおりにデコードするコードを書く。</p><pre>  // receiving a response<br>  if (data[0] == 0x55 &amp;&amp; data[1] == 0xaa) {<br>    <br>    // check sum<br>    var checksum = data[10] + (data[11] &lt;&lt; 8);<br>    if (checksum != getChecksum(data)) {<br>      console.log(&#39;Checksum error: &#39; + toHexString(data));<br>      return;<br>    }<br><br>    // decode param and comm<br>    respParam = data[4] + (data[5] &lt;&lt; 8) + (data[6] &lt;&lt; 16) + (data[7] &lt;&lt; 24);<br>  }</pre><p>このコマンド送信とレスポンス受信のコードを使って、ガイドにあるコマンドを送る。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Sn1PayEuYyVfCBZJWe7rTQ.png" /></figure><p>例えば指紋認証を行うときは、まず CmosLed を送ってスキャナの LED を点灯させ、 CaptureFinger で指紋画像を保存、 Identify で指紋認証して指紋 ID を取得する、という流れだ。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*AmO14BG1Al9k-YzIiKrZrQ.png" /></figure><p>バイト列をエンコードしたりデコードしたりするの楽しい。</p><h4>指が押されたか検知する</h4><p>この指紋認証のフローを開始する前に、まず指が押されたかを検知する必要があるけど、指紋スキャナにある IsPressFinger の反応がいまいち良くない。冒頭のビデオのように、LED がつけっぱなしになるし、指を置いてから 1 秒くらい間が空いてしまう。もっとさくっと検知したいのだ。</p><p>obniz の対応ハードウェアリストに<a href="https://obniz.io/sdk/parts/FSR-40X/README.md?iframe=false">感圧センサ</a>があったので、これを指紋スキャナの裏側に張って、圧力がかかったら LED を点けて指紋認証を開始するようにした。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/753/0*IFdrMKFsNfx4ehVa.png" /></figure><p>これで、認識開始までの遅延が 0.3 秒くらいに短縮できた。よしよし。</p><h4>管理画面をつくる</h4><p>指紋の登録や削除、認証テストのための UI を obniz の HTML で作る。obniz って、こういうちょっとした UI が簡単につくれるのがいいね。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/982/1*O21l3r_ZEDiXoyP3BZ4xeQ.png" /></figure><h4>IFTTT の webhook で Switchbot を動かす</h4><p>Qrio Lock には API がないので、カギの解錠と施錠はどうしようかと悩んだ末に、困った時の IFTTT 頼み。obniz から webhook をコールして、Switchbot で Qrio Key のボタンを押す。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/432/1*TBbFFIzRs6F6sS0F4-Opfw.png" /></figure><p>これでできあがり。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*VNXTEs6RAdAlSL1sS2F34w.png" /></figure><h4>使ってみた感想</h4><ul><li>指紋認証してから実際にカギが開くまで 3〜4 秒かかる</li><li>指紋スキャナの反応がいまいちで、3 回中 2 回くらい認証に失敗する ← バグを直したら認証に失敗しなくなった</li><li>全体的にコストが高い</li><li>obniz のブラウザ画面をつねに foreground にしとかないと JS のイベントループが 1 秒ごとの呼び出しになってしまい使いものにならない（Node.js に載せれば解決するだろうけど、UI 作るの面倒だ）</li><li>obniz の電源を取るために 長い USB ケーブルを引き回して窓に挟めてる</li><li>まあでも 手ぶらでカギ開けたり締めたりできるの便利（マンションロビーのオートロック問題があるけど）</li></ul><p>Disclaimer: この記事は個人的なものです｡ここで述べられていることは私の個人的な意見に基づくものであり､私の雇用者には関係はありません｡</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d5f14ab2297d" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[obniz でつくるウェザークロック]]></title>
            <link>https://medium.com/@kazunori279/obniz-%E3%81%A7%E3%81%A4%E3%81%8F%E3%82%8B%E3%82%A6%E3%82%A7%E3%82%B6%E3%83%BC%E3%82%AF%E3%83%AD%E3%83%83%E3%82%AF-dcc54c6b41d0?source=rss-4b21e207ea2c------2</link>
            <guid isPermaLink="false">https://medium.com/p/dcc54c6b41d0</guid>
            <category><![CDATA[iot]]></category>
            <dc:creator><![CDATA[Kaz Sato]]></dc:creator>
            <pubDate>Thu, 27 Dec 2018 08:45:46 GMT</pubDate>
            <atom:updated>2018-12-27T08:45:46.000Z</atom:updated>
            <content:encoded><![CDATA[<p>最近、<a href="https://obniz.io/">obniz</a> をいじるのが好きで、2 種類のウェザークロックを作ったのでメモしておく（機械学習は出てこない）。</p><h3>シンプルなウェザークロック</h3><p>市販のウェザークロックって気圧変化で天気を予測してるから、ネットの天気予報のようなきめ細かな予測って難しいし、かといってネットにつながるウェザークロックは数万円する。ネットの天気予報を分かりやすく表示するクロックがほしいなと思ってたので、obniz の練習として最初に作ってみた。コードは<a href="https://github.com/kazunori279/obniz_samples/blob/master/weather_clock/weather_clock.html">ここ</a>。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*YbZy-i_BDUqqzyrw" /></figure><p>無料の天気予報の API をいろいろ探したところ、<a href="https://darksky.net/dev">Dark Sky</a> ってサービスがよさげだった。この API を jQuery の ajax で呼び出す。</p><pre>https://api.darksky.net/forecast/[key]/[latitude],[longitude]</pre><p>すると、指定した場所の天気予報が帰ってくる。</p><pre>GET https://api.darksky.net/forecast/0123456789abcdef9876543210fedcba/42.3601,-71.0589<br>      <br>      {<br>          &quot;latitude&quot;: 42.3601,<br>          &quot;longitude&quot;: -71.0589,<br>          &quot;timezone&quot;: &quot;America/New_York&quot;,<br>          &quot;currently&quot;: {<br>              &quot;time&quot;: 1509993277,<br>              &quot;summary&quot;: &quot;Drizzle&quot;,<br>              &quot;icon&quot;: &quot;rain&quot;,<br>              &quot;nearestStormDistance&quot;: 0,<br>              &quot;precipIntensity&quot;: 0.0089,<br>              &quot;precipIntensityError&quot;: 0.0046,<br>              &quot;precipProbability&quot;: 0.9,<br>              &quot;precipType&quot;: &quot;rain&quot;,<br>              &quot;temperature&quot;: 66.1,<br>              &quot;apparentTemperature&quot;: 66.31,<br>              &quot;dewPoint&quot;: 60.77,<br>              &quot;humidity&quot;: 0.83,<br>              &quot;pressure&quot;: 1010.34,<br>              &quot;windSpeed&quot;: 5.59,<br>              &quot;windGust&quot;: 12.03,<br>              &quot;windBearing&quot;: 246,<br>              &quot;cloudCover&quot;: 0.7,<br>              &quot;uvIndex&quot;: 1,<br>              &quot;visibility&quot;: 9.84,<br>              &quot;ozone&quot;: 267.44<br>          },<br>...</pre><p>現在の天気のほか、毎時および毎日単位で向こう 7 日間の予報を JSON で返してくれるので、これをパースしてラベルやアイコンを表示するだけ。簡単だ。15 分に 1 回呼び出す設定にしたので、個人利用なら無料枠でずっと使える。</p><p>obniz には <a href="https://obniz.io/doc/sdk/doc/display">OLED ディスプレイに文字を表示する API</a> が用意されてるので、それを使って時刻と天気を表示する。これ、JS コードが動いてるブラウザの Canvas でビットマップを描いて送信する仕組みのようで、ブラウザが変わるとフォントも変化したりする。</p><h3>LED リングで作るウェザークロック</h3><p>次に、<a href="https://www.switch-science.com/catalog/1861/">Adafruit の LED リング</a>で天気予報を表示する時計を作った。コードは<a href="https://github.com/kazunori279/obniz_samples/blob/master/weather_clock/ledclock.html">ここ</a>。Dark Sky API で得られる降水確率（precipIntencity）が高いと青、曇り確率（cloudCover）が低いと緑、それ以外は白でお天気を表示する。赤は時針だ。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FbOyV7lKLFxY%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DbOyV7lKLFxY&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FbOyV7lKLFxY%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/3e2847d8966fdbaca59bed50dfc079dc/href">https://medium.com/media/3e2847d8966fdbaca59bed50dfc079dc/href</a></iframe><p>LED リングは 1/4 ずつバラバラで販売されてるので、<a href="https://www.adafruit.com/product/1768">Adafruit のドキュメント</a>を参考に、はんだ付けしてリングを作る。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/970/0*QV5QLJ8nI_oakdgn.jpg" /></figure><p>このdin を obniz の開いてる IO ポートにつなぐ。 5V と GND は obniz の USB ポートそばにある 5V と GND にはんだ付けする（LED の電源を IO ポートから取ると容量が足りなくなる）。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/507/1*f_YVrCxXcMUtsNPc8RX0hQ.png" /></figure><p>個々の LED の制御ってどうやんのかな？ と思ってたけど、この LED リングは obniz が標準サポートする LED ドライバー <a href="https://obniz.io/sdk/parts/WS2812/README.md?iframe=false">WS2812</a> を使ってたので簡単に書けた。</p><pre>led = obniz.wired(&quot;WS2812&quot;, {din: 0});</pre><p>こんなふうにして初期化したら、</p><pre>led.hsvs([<br>  [180, 0.5, 1],<br>  [0, 1, 1],<br>  ... <br>])</pre><p>ってふうに、HSV （色相、彩度、明度）の配列を LED の個数だけ送ると、その色と明るさで光ってくれる。簡単。</p><h4>分針や秒針 のトランジション表示</h4><p>面倒だったのは、天気予報を色で表示しつつ、時針、分針、そして秒針を重ねて表示するところ。パカパカ点滅するのはかっこわるいので、</p><ul><li>60 個ある LED のベースの色を<a href="https://github.com/kazunori279/obniz_samples/blob/master/weather_clock/ledclock.html#L165">天気予報に基づいて決める</a></li><li>その上に、<a href="https://github.com/kazunori279/obniz_samples/blob/master/weather_clock/ledclock.html#L191">時針、分針、秒針を重ねる</a></li><li>個々の LED について、<a href="https://github.com/kazunori279/obniz_samples/blob/master/weather_clock/ledclock.html#L96">前の色から次の色への移行を 1/10 秒単位で更新</a>する</li></ul><p>ってコードを書いた。これで、秒針や分針が移動するときはふわーっと動く。</p><h4>環境の明るさに応じて輝度制御</h4><p>誰も見てない真夜中に煌々と光らせとくのもいまいちだし、日中の明るさに合わせて輝度を設定すると夜まぶしいので、<a href="https://www.switch-science.com/catalog/37/">明るさセンサ</a>を付けて<a href="https://github.com/kazunori279/obniz_samples/blob/master/weather_clock/ledclock.html#L206">輝度制御</a>した。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/500/0*CmLo9zC_-nEqTRNG.jpg" /></figure><p>obniz の AD変換 で電圧を読み取って LED の輝度を調整するのだけど、室内の明るさと電圧変化の比率が昼と夜とでは全然変わる（というか人間が感じる明るさの度合いが非線形なのだろう）。昼の明るさは log を挟むようにした。また、安いセンサーなので夜間の微妙な明るさの違いを検出するのが難しかったけど、AD の電圧を積分するといい感じ。</p><h4>フォトフレームに入れる</h4><p>近所のケーヨーデイツーにぴったりな大きさのフォトフレームがあった。そのままでは LED が眩しすぎるので、紙を何枚か重ねて輝度を調節する。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*1a4onZsvn57GlDrz" /></figure><p>これでできあがり。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*y5h5_1mWUEJeuIfq" /></figure><p>Disclaimer: この記事は個人的なものです｡ここで述べられていることは私の個人的な意見に基づくものであり､私の雇用者には関係はありません｡</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=dcc54c6b41d0" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[寝かしつけについて]]></title>
            <link>https://medium.com/@kazunori279/%E5%AF%9D%E3%81%8B%E3%81%97%E3%81%A4%E3%81%91%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6-252852c6e0a3?source=rss-4b21e207ea2c------2</link>
            <guid isPermaLink="false">https://medium.com/p/252852c6e0a3</guid>
            <category><![CDATA[tensorflow]]></category>
            <category><![CDATA[iot]]></category>
            <dc:creator><![CDATA[Kaz Sato]]></dc:creator>
            <pubDate>Thu, 20 Dec 2018 09:02:57 GMT</pubDate>
            <atom:updated>2018-12-20T09:02:57.434Z</atom:updated>
            <content:encoded><![CDATA[<p>この記事は <a href="https://qiita.com/advent-calendar/2018/tensorflow">TensorFlow Advent Calendar 2018</a> の 20 日目の記事です。</p><p>最近、会社の同僚に子供が生まれた。深夜の夜泣きに目が覚めてしまうそうで、昼間も眠そうだ。苦労をお察しする。俺も息子が赤ん坊のころは夜中の 2 時に起こされて寝かしつけしてたのを思い出した。</p><p>赤ん坊は生まれた時点で洗練された認知能力をすでに備えており、親のズルを許さない。ソファに座ったままだっこして揺らす、という行為は手抜きとして認識され、いつまでも泣き止まない。そこで、強い眠気でふらふらになりながらも赤ん坊を抱えて立ち、母親の胎内にいるかのようにゆ〜らゆ〜らと優しくゆりうごかしてあげると、こちらが意識を失うあたりで向こうも寝付くのだ。</p><p>しかしここでゆっくりソファに座ると、たちまち赤ん坊の加速度センサーが手抜きを検知し、ふたたび泣き始めるのである。</p><p>本稿では、この寝かしつけの苦労を obniz と TensorFlow.js で再現する手順を解説する。</p><p><a href="https://obniz.io/">obniz</a> はよくできた IoT デバイスだ。アマゾンで 6000 円ほど。箱を開けて USB 電源につないだら WiFi のパスワードを入れ、ブラウザ上で JavaScript コードを書いて helloworld するまで 5 分もかからない。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JurY2zP8SFq-YXvQ" /></figure><p>書いたコードはブラウザで動いてる。要するにこれはいろいろな電子部品にブラウザ JS から WiFi 経由で読み書きするためのデバイスだ。</p><p>これに、<a href="https://obniz.io/sdk/parts/KXR94-2050/README.md?iframe=false">秋月で買った加速度センサー</a>をつなぐ。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*V8q9PXua2BkS1Dl2" /></figure><p>セロテープで留めた。雑でいいのだ。</p><p>obniz のドキュメントにあるコードをコピペして数行書けば、このセンサーが検知した x、y、z 方向の加速度を JS で読み出せる。</p><pre>// init sensor<br>var sensor = obniz.wired(&quot;KXR94-2050&quot;, { vcc:5, enable:6, gnd:7, z:8, y:9, x:10, self_test:11 });</pre><pre>// get sensor values<br>while (true) {<br>  let values = sensor.get();<br>  console.log(&quot;x:&quot; + values.x);<br>  console.log(&quot;y:&quot; + values.y);<br>  console.log(&quot;z:&quot; + values.z);<br>  await obniz.wait(30);<br>}</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/618/1*Qnje4zTGzCxK7FyMR4-Ejg.png" /></figure><p>生の数字を眺めても意味がわからない。<a href="https://threejs.org/">three.js</a> を使ってセンサーの値を 3D 表示してみた。下の黒い板はモバイルバッテリーである。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FYZ5hxmpLlWo%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DYZ5hxmpLlWo&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FYZ5hxmpLlWo%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/7df452e6af98fd58c96bd8834b5be1fb/href">https://medium.com/media/7df452e6af98fd58c96bd8834b5be1fb/href</a></iframe><p>毎秒 10 回くらいで読める。時間をかけて 3D にしてみたが、かえって見づらいので後悔した。D3.js にしておけばよかった。</p><p>昨晩、俺はこのデバイスを腕に抱え、12 年前の辛い時期のことを思い出しながら、こんなふうにしたっけな、と、寝かしつけをしていた。まあ今回は、そんなに長い時間をかける必要はない。1 分間で十分だ。ついでに、赤ちゃん大好き「高い高い」、いちばん嫌いな「床に放置」、そして「はげしく揺さぶる」も 1 分間ずつ記録した。CSV にして localStorage に入れておいた。</p><p><a href="https://js.tensorflow.org/">TensorFlow.js</a> は、JavaScript で動く ML ライブラリである。加速度センサーやら、なんちゃらセンサーやら、たくさんの数字を集めたって、人が書く if 文でできることはたかが知れているのである。だから、obniz を使い始めた当初から、TF.js と使うことを考えていた。</p><p>x、y、z の 3 つの数字が時系列で流れてくるとき、そのパターンをどのようにして知ればよいか。x、y、z を画素の色、時間軸を画素の並びと捉えれば、この直線の模様を画像認識できればよい。画像認識といえば CNN である。直線だから 1 次元の CNN でよい。RNN や LSTM を使ってもいいけど、なんかめんどくさそうなのでやらない。</p><p><a href="http://www.jussihuotari.com/2017/12/20/spell-out-convolution-1d-in-cnns/">ここ</a>に 1 次元 CNN のいい図があった。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/300/0*vm9qNncWvP0O5nPk.png" /></figure><p>この赤い枠がフィルタというもので、太いシマシマや細いシマシマの模様のついた色眼鏡のようなものだ。この色眼鏡を少しずつずらしながら数字を見ていくと、模様にぴったり合うところで数字がばっちり見える。ここには太いシマシマがあるぞ、とわかる。そして、いろんな模様のフィルタをたくさん作り、それら全部使って数字を眺めていけば、どんな模様がどこにあるかがわかる。</p><p>TensorFlow.js では、こういう 1 次元の CNN を作るための conv1d 関数があるので使ってみる。</p><pre>const model = tf.sequential();</pre><pre>model.add(<br>  tf.layers.conv1d({<br>    inputShape: [20, 3],<br>    kernelSize: 10,<br>    filters: 50,<br>    strides: 1,<br>    activation: “relu”,<br>    kernelInitializer: “randomNormal”<br>  })<br>);</pre><p>ここでは、センサーの値を 20 個（つまりおよそ 2 秒分）ごとに区切り、x、y、z の値を持つ [20, 3] の tensor として入力する。この直線の模様を見分ける長さ 10 のフィルタを 50 個用意する。この 10 とか 50 とかの設定の調整を本気でやると面倒だが、仕事じゃないので適当に済ませておく。学習がうまく行けば、TF.js のオプティマイザが、 x、y、z の変化のパターンをうまく見分けられるいい塩梅のフィルタを 50 種類作ってくれる。</p><p>この conv1d 層から出てくる数字をざっくりまとめる maxPooling1d 層をつなげる。さらに、数字をわざとランダムに消すことで融通の利くモデルに育てるdropout 層、そして最後に、こんな模様の数字の並びはいったいどんな寝かしつけなのかを判断する dense 層をつなげる。</p><pre>conv1d_Conv1D1 (Conv1D) [null,11,50]<br>max_pooling1d_MaxPooling1D1 [null,5,50]<br>flatten_Flatten1 (Flatten) [null,250]<br>dropout_Dropout1 (Dropout) [null,250]<br>dense_Dense1 (Dense) [null,4]</pre><p>ちなみに、1 次元 CNN をもっときちんと理解してがっちり作るには、yuta さんが教えてくれたこのページが大変参考になる。</p><h3>Yuta Kashino on Twitter</h3><p>@kazunori_279 おお、kerasのlayerのConv1Dですか。これはどうでしょうか？https://t.co/vP3aJaalMB</p><p>あと、学習をはじめたところ、どうやっても loss が NaN にしかならず、頭を抱えた。</p><h3>Kazunori Sato on Twitter</h3><p>NaNでだろ〜NaNでだろ〜♪（赤と青のジャージで</p><p>そこで TF.js のオーソリティ、飯塚先生に見てもらったら、環境依存問題だったことがすぐに分かり助かった。ありがとうございました。</p><p>4 種類の動作をそれぞれ 1 分間記録すると、 x、y、z が 20 個ずつ入った tensor が 128 個できる。このうち 100 個を学習用、28 個をテスト用に分け、学習を始めると、おおよそ 1 分くらいで 96% 精度を超える。</p><pre>07:40:57 Start training…<br>07:41:05 loss: 1.24, acc: 0.54<br>07:41:11 loss: 1.03, acc: 0.54<br>07:41:18 loss: 0.88, acc: 0.54<br>07:41:24 loss: 0.76, acc: 0.61<br>07:41:30 loss: 0.67, acc: 0.64<br>07:41:36 loss: 0.59, acc: 0.75<br>07:41:43 loss: 0.52, acc: 0.82<br>07:41:49 loss: 0.46, acc: 0.86<br>07:41:55 loss: 0.41, acc: 0.93<br>07:42:01 loss: 0.37, acc: 0.96<br>07:42:08 loss: 0.34, acc: 0.96<br>07:42:14 loss: 0.30, acc: 1.00<br>07:42:14 Training finished.</pre><p>データが少ないから過学習してるかもだが、試してみた分にはそれっぽく動いてるのでよしとする。TF.js ではモデルの save 関数で local storage にモデルを入れておけて便利である。</p><p>ここまでのコードは<a href="https://github.com/kazunori279/obniz_samples/tree/master/acc_detector">ここ</a>に置いてある。</p><p>ではこれを寝かしつけてみる。obniz そのままでは無骨なので、もふもふ動物ポーチに入れた。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*o_8CH2woHeJkUlTq" /></figure><p>obniz の画面があるところを切り抜き、動きに応じた表情を見せることで、より寝かしつけ感を出してみた。</p><p>こんな感じになった。</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F-OCWGPzSqEs%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D-OCWGPzSqEs&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F-OCWGPzSqEs%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/c1fc430e518da1ef75660584133e76c2/href">https://medium.com/media/c1fc430e518da1ef75660584133e76c2/href</a></iframe><p>動物は、机に放置されてるときは悲しいので、泣き顔である。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/948/1*5a5OUCsUP3WNxREN6nv0cA.png" /></figure><p>しかし人が抱えてくれると泣き止む。好奇心まんまんである。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1010/1*9NmOS7ZtuviTYjMM3CJU_Q.png" /></figure><p>はげしく揺さぶって見る。目を回した。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/330/1*g1pLtd1xfqXeE6jSPMd0bQ.png" /></figure><p>高い高いすると喜ぶ。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/694/1*U6m8m7LPUFuA1lyD02v0Dg.png" /></figure><p>ゆっくりと、やさしく寝かしつける。やがてすやすやと眠りに落ちる。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*F17IIc9gkEUICXo9xgOklw.png" /></figure><p>寝たかな、と思って、机にそっと戻すと、すぐ起きてしまうのだ。</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*HpZJSyBC-ZVNCeYd4YKkQg.png" /></figure><p>Disclaimer: この記事は個人的なものです｡ここで述べられていることは私の個人的な意見に基づくものであり､私の雇用者には関係はありません｡</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=252852c6e0a3" width="1" height="1" alt="">]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Build the world’s largest IoT with RasPi and Google BigQuery]]></title>
            <link>https://medium.com/google-cloud/build-the-world-s-largest-iot-with-raspi-and-google-bigquery-169b332d02b1?source=rss-4b21e207ea2c------2</link>
            <guid isPermaLink="false">https://medium.com/p/169b332d02b1</guid>
            <dc:creator><![CDATA[Kaz Sato]]></dc:creator>
            <pubDate>Fri, 17 Jul 2015 22:37:40 GMT</pubDate>
            <atom:updated>2015-07-17T22:44:06.960Z</atom:updated>
            <content:encoded><![CDATA[<p>This is my weather station built with RasPi. It took only several hours in my weekend to build this, but it’s already capable of deploying the world’s largest IoT platform. Why? Because it directly sends the metrics to <a href="https://cloud.google.com/bigquery/">Google BigQuery</a>, the massively parallel query engine from Google Cloud Platform which is able to collect <strong>one million rows of metrics every second</strong> and execute query on <strong>terabytes of data in 10 seconds</strong>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/466/0*AC4y23wNyqKVFebj.png" /></figure><p>So, you can start deploying millions of this box to collect temperature, humidity and atmospheric pressure (or any metrics if you add sensors) from everywhere in the world, right now. I don’t have to do anything more to build a large distributed frond ends, load balancers, app servers and super-fast database cluster with scaling out, fail-over, replication and etc — the complications required to build a large production IoT platform. BigQuery has them all in Google’s largest Datacenter with Google scale and quality.</p><p>The RasPi box runs a simple <a href="https://github.com/kazunori279/raspi/tree/master/weather_report">Python code</a> to send the metrics to BigQuery that will be aggregated and shown as graphs on Google Spreadsheet.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/893/0*eyRzMqyFJ5-UqtAZ.png" /></figure><p>The total cost for building this is less than $100. You only need to buy the RasPi box and buy some sensors and that’s it. Google Spreadsheet is free. Google BigQuery is outrageously inexpensive: the storage cost is 20 cents / GB / month and the query cost is a few cents for querying on 100M rows each time. Most importantly, it’s a fully managed service. You don’t have to hire tens of senior engineers to build and operate the world’s largest big data cluster.</p><p>Let’s take a look at how you can build this box in your weekend.</p><h3>Connecting Sensors to RasPi</h3><p>The followings are the parts you need to buy:</p><ul><li><a href="http://amzn.com/B00T2U7R7I">RasPi</a>, <a href="http://amzn.com/B00ELL7F1G">NOOBS SD Card</a>, <a href="http://amzn.com/B003MTTJOY">USB WiFi</a></li><li>USB Power for RasPi</li><li><a href="http://amzn.com/B00SK6940I">DHT22</a>, temperature and humidity sensor</li><li>Resistor for DHT 22 (5K to 10K ohm)</li><li><a href="http://www.mouser.com/newproducts/newproductsmanufacturers.aspx?mfg=stmicroelectronics&amp;virtualdir=stmlps331/">LPS331</a>, atmospheric pressure sensor</li><li>Breadboard and jumper wires</li></ul><p>By using the NOOBS SD card, it’s so easy to setup RasPi. The USB WiFi should also be easy to set up with the OS’ config tool.</p><p>For connecting the sensors to RasPi, you may refer to the following page:</p><ul><li><a href="https://learn.adafruit.com/dht-humidity-sensing-on-raspberry-pi-with-gdocs-logging/overview">DHT Humidity Sensing on Raspberry Pi</a></li></ul><figure><img alt="" src="https://cdn-images-1.medium.com/max/578/0*VnUp7SONa9cZO9T7.png" /></figure><p>From <a href="https://learn.adafruit.com/dht-humidity-sensing-on-raspberry-pi-with-gdocs-logging/overview">DHT Humidity Sensing on Raspberry Pi</a></p><p>No special circuitry is required. You can connect GPIO pins of RasPi to the sensors with a breadboard. One caveat is that you have to keep DHT22 away from RasPi box to avoid the heat from CPU. For LPS331, you may use any other pressure sensors that can be attached to RasPi.</p><h3>Installing Drivers with Ansible</h3><p>It’s not so easy to write drivers for the sensors. Especially, DHT22 takes a little effort. But the cool thing about using RasPi is that you can find them <a href="https://learn.adafruit.com/dht-humidity-sensing-on-raspberry-pi-with-gdocs-logging/software-install-updated">on GitHub</a>.</p><p>Another cool thing is that RasPi is a Linux. You can use Ansible Playbook like the following to install drivers on GitHub for the sensors.</p><pre>    # Adafruit DHT drivers<br>    - git: repo=git@github.com:adafruit/Adafruit_Python_DHT.git<br>           dest={{ dht_dir }} accept_hostkey=yes<br>      sudo: no<br>    - command: python setup.py install chdir={{ dht_dir }}</pre><p>Although you may need to wait a while until finishing the Playbook execution :)</p><h3>Decode Sensor Values by Python</h3><p>The LPS331 pressure sensor uses I2C bus protocol for communication. With Python, you can use i2ctools command to read the values from the sensor.</p><pre>def cmd_exec(cmd):<br>    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)<br>    stdout, stderr = p.communicate()<br>    if stderr != None and len(stderr.strip()) &gt; 0:<br>        raise IOError(&quot;Error on executing cmd: &quot; + stderr)<br>    return stdout.strip()<br><br>def i2cget(reg):<br>    return cmd_exec(&quot;i2cget -y 1 &quot; + LPS331_ADRS + &quot; &quot; + reg)</pre><p>The code let you execute i2cget command as a sub process. So that you can read values from I2C registors to calculate pressure values.</p><pre>def read_lps():<br><br>    # reading from LPS<br>    out0 = i2cget(&quot;0x28&quot;)<br>    out1 = i2cget(&quot;0x29&quot;)<br>    out2 = i2cget(&quot;0x2a&quot;)<br><br>    # decoding the value<br>    return (int(out0, 16) + (int(out1, 16) * 0x100) + (int(out2, 16) * 0x10000)) / 4096.0</pre><p>DHT22 temperature and humidity sensor could be read easily by using the Adafruit Python driver.</p><pre># read humidity and temp from DHT <br>humidity, temp = Adafruit_DHT.read_retry(Adafruit_DHT.DHT22, DHT22_GPIO)</pre><h3>Use Fluentd to Send to BigQuery</h3><p>Now it’s ready to send the metrics to BigQuery. You can use <a href="https://cloud.google.com/solutions/real-time/fluentd-bigquery">Fluentd</a>, the popular open source log collector, to do this. The following is the Ansible Playbook for installing Fluentd and its BigQuery plugin:</p><pre>    # Fluentd<br>    - command: aptitude install ruby-dev<br>    - command: gem install fluentd<br><br>    # pip, fluent-logger-python, fluent-plugin-bigquery<br>    - command: aptitude install python-pip<br>    - command: pip install fluent-logger<br>    - command: fluent-gem install fluent-plugin-bigquery</pre><p>On fluentd.conf, you can add the following config to receive the event log from fluent-logger-python and forward it to fluent-plugin-bigquery.</p><pre>&lt;source&gt;<br>  type forward <br>  port 24224<br>&lt;/source&gt;<br><br>&lt;match weather.**&gt;<br>  type bigquery<br><br>  method insert<br><br>  auth_method private_key<br>  email YOUR_SERVICE_ACCOUNT_EMAIL <br>  private_key_path YOUR_PRIVATE_KEY_FILE_PATH <br><br>  project YOUR_PROJECT_ID <br>  dataset YOUR_DATASET <br>  table YOUR_TABLE_NAME <br><br>  time_format %s<br>  time_field time<br><br>  fetch_schema true<br>  field_integer time<br>&lt;/match&gt;</pre><p>In Python code, use fluent-logger-python API to send the metrics to Fluentd.</p><pre>    # write metrics to local fluentd<br>    event.Event(&quot;metrics&quot;, {<br>        &quot;atmos&quot;: atmos,<br>        &quot;hum&quot;: humidity,<br>        &quot;temp&quot;: temp<br>    })</pre><h3>Create a Table and Key on BigQuery</h3><p>Next, set up BigQuery to receive the event log from Fluentd. If this is the first time for you to start using the query service, please take a look at the <a href="https://cloud.google.com/bigquery/sign-up">getting started guide</a> to prepare a Google Cloud Platform project and BigQuery dataset.</p><p>For this demo, I’ve created a BigQuery table to receive the metrics. You may need to add a column to hold IDs of each device if you want to collect metrics from multiple devices.</p><pre>[<br>  {<br>    &quot;name&quot;: &quot;time&quot;,<br>    &quot;type&quot;: &quot;INTEGER&quot;<br>  },<br>  {<br>    &quot;name&quot;: &quot;hum&quot;,<br>    &quot;type&quot;: &quot;FLOAT&quot;<br>  },<br>  {<br>    &quot;name&quot;: &quot;temp&quot;,<br>    &quot;type&quot;: &quot;FLOAT&quot;<br>  },<br>  {<br>    &quot;name&quot;: &quot;atmos&quot;,<br>    &quot;type&quot;: &quot;FLOAT&quot;<br>  }<br>]</pre><p>By using <a href="https://cloud.google.com/bigquery/bq-command-line-tool">bq command</a>, execute the following line to create a table with the schema above.</p><pre>&gt; bq mk -t &lt;your-project-id&gt;:&lt;your_dataset&gt;.weather_report wr_bqschema.json</pre><p>Then, create a private key to connect from the RasPi box to BigQuery. At Google Developers Console, open APIs and auth menu and create a new Client ID for a service account.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/685/0*L-deP62kpdI_RMgb.png" /></figure><p>This will start downloading of the private key. Copy the key to RasPi box, and edit fluentd.conf to set private_key_path field to the path of the key file. Also, set email field to the email address of the service account.</p><h3>Execute a Query on BigQuery</h3><p>Now it’s ready to try. On RasPi, execute the following to initiate Fluentd.</p><pre>&gt; fluentd -c fluentd.conf</pre><p>And open another shell to execute the python code.</p><pre>&gt; sudo python weather_report.py</pre><p>If it runs successfully, you would see anything on the console. Go to BigQuery Console and execute the following SQL.</p><pre>SELECT <br>  LEFT(STRING(SEC_TO_TIMESTAMP(time)), 15) + &#39;0:00&#39; as time,   <br>  AVG(temp) as temp,<br>  AVG(hum) as hum, <br>  AVG(atmos) as atmos <br>FROM [YOUR_PROJ:YOUR_DATASET.weather_report] <br>GROUP BY time <br>ORDER BY time DESC</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/942/0*nbEYrqP2yI1hIcSD.png" /></figure><p>Sounds like it’s working! This query aggregates the 10 min average metrics and sort them with the timestamp.</p><p>Because it’s running on BigQuery, you could get the result of this query in 10 seconds even when you collect 100 billion rows of metrics. See <a href="https://cloud.google.com/files/BigQueryTechnicalWP.pdf">this white paper</a> to learn why it could be possible. In short, the service runs <strong>thousands of servers in parallel</strong> for every single query.</p><p>Now you are ready to send any metrics of any number of IoT devices — sensors in appliances, cars, mobile devices, factory machinery and etc — to BigQuery without any concerns about the scalability and availability.</p><h3>Draw a Graph with Google Spreadsheet</h3><p>By using Google Spreadsheet and its Google Apps Script, you can execute the BigQuery query from it and draw a graph from the result. Please look at <a href="https://cloud.google.com/solutions/real-time/fluentd-bigquery">Real-time log analysis using Fluentd and BigQuery</a> to learn how to do this. No need to write your own script. You can just copy the sheet and script in the document and use it to draw a graph like this.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/575/0*cU8WtB9oDXt4yGFb.png" /></figure><p>As you have seen on this article, it’s so fun to play with RasPi, especially when you are connecting it with the powerful cloud toolings such as BigQuery and Fluentd. Even though it’s just a hobby in weekend, you could already get the fully managed, highly scalable and available IoT platform without spending much money.</p><p>The sample code for this demo is available on <a href="https://github.com/kazunori279/raspi/tree/master/weather_report">my GitHub repo</a>.</p><p><em>Originally published at </em><a href="http://qiita.com/kazunori279/items/0f8d827ac9966c9804ab"><em>qiita.com</em></a><em>.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=169b332d02b1" width="1" height="1" alt=""><hr><p><a href="https://medium.com/google-cloud/build-the-world-s-largest-iot-with-raspi-and-google-bigquery-169b332d02b1">Build the world’s largest IoT with RasPi and Google BigQuery</a> was originally published in <a href="https://medium.com/google-cloud">Google Cloud - Community</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>