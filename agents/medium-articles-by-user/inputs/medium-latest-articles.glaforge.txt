
== Article 1
* Title: 'Let’s make Gemini Groovy!'
* Author: 'Guillaume Laforge'
* URL: 'https://medium.com/google-cloud/lets-make-gemini-groovy-7481ac6add04?source=rss-431147437aeb------2'
* PublicationDate: 'Mon, 03 Jun 2024 00:00:24 GMT'
* Categories: gemini, groovy, java, generative-ai, langchain4j

The happy users of Gemini Advanced, the powerful AI web assistant powered by the Gemini model, can execute some Python code, thanks to a built-in Python interpreter. So, for math, logic, calculation questions, the assistant can let Gemini invent a Python script, and execute it, to let users get a more accurate answer to their queries.But wearing my Apache Groovy hat on, I wondered if I could get Gemini to invoke some Groovy scripts as well, for advanced math questions!LangChain4j based approachAs usual, my tool of choice for any LLM problem is the powerful LangChain4j framework! Interestingly, there are already some code engine integrations,a GraalVM Polyglot Truffle engine, that can execute Python and JavaScript code,a Judge0 engine that uses the Judge0 online code execution system, which also supports Groovy!I haven’t tried Judge0 yet, as I saw it was supporting Groovy 3 only, and not yet Groovy 4. But for math or logic questions, Groovy 3 is just fine anyway. Instead, I wanted to explore how to create my own Groovy interpreter!In the following experiment, I’m going to use the Gemini model, because it supports function calling, which means we can instruct the model that it can use some tools when needed.Let’s walk through this step by step.First, I instantiate a Gemini chat model:var model = VertexAiGeminiChatModel.builder()    .project("MY_GCP_PROJECT_ID")    .location("us-central1")    .modelName("gemini-1.5-flash-001")    .maxRetries(1)    .build();Then, I create a tool that is able to run Groovy code, thanks to the GroovyShell evaluator:class GroovyInterpreter {  @Tool("Execute a Groovy script and return the result of its execution.")  public Map&lt;String, String&gt; executeGroovyScript(    @P("The groovy script source code to execute") String groovyScript) {    String script = groovyScript.replace("\\n", "\n");    System.err.format("%n--&gt; Executing the following Groovy script:%n%s%n", script);    try {      Object result = new GroovyShell().evaluate(script);      return Map.of("result", result == null ? "null" : result.toString());    } catch (Throwable e) {      return Map.of("error", e.getMessage());    }  }}Notice the @Tool annotation that describes what this tool can do. And the@P annotation which explains what the parameter is about.I noticed that sometimes the raw script that Gemini suggested contained some \n strings, instead of the plain newline characters, so I'm replacing them with newlines instead.I return a map containing either a result (as a string), or an error message if one was encountered.Now it’s time to create our assistant contract, in the form of an interface, but with a very carefully crafted system instruction:interface GroovyAssistant {  @SystemMessage("""    You are a problem solver equipped with the capability of \    executing Groovy scripts.    When you need to or you're asked to evaluate some math \    function, some algorithm, or some code, use the \    `executeGroovyScript` function, passing a Groovy script \    that implements the function, the algorithm, or the code \    that needs to be run.    In the Groovy script, return a value. Don't print the result \    to the console.    Don't use semicolons in your Groovy scripts, it's not necessary.    When reporting the result of the execution of a script, \    be sure to show the content of that script.    Call the `executeGroovyScript` function only once, \    don't call it in a loop.    """)  String chat(String msg);}This complex system instruction above tells the model what its role is, and that it should call the provided Groovy script execution function whenever it encounters the need to calculate some function, or execute some logic.I also instruct it to return values instead of printing results.Funnily, Gemini is a pretty decent Groovy programmer, but it insists on always adding semi-colons like in Java, so for a more idiomatic code style, I suggest it to get rid of them!The final step is now to create our LangChain4j AI service with the following code:var assistant = AiServices.builder(GroovyAssistant.class)    .chatLanguageModel(model)    .chatMemory(MessageWindowChatMemory.withMaxMessages(20))    .tools(new GroovyInterpreter())    .build();I combine the Gemini chat model, with a memory to keep track of users’ requests, and the Groovy interpreter tool I’ve just created.Now let’s see if Gemini is able to create and calculate a fibonacci function:System.out.println(  assistant.chat(    "Write a `fibonacci` function, and calculate `fibonacci(18)`"));And the output is as follows:def fibonacci(n) {  if (n &lt;= 1) {    return n  } else {    return fibonacci(n - 1) + fibonacci(n - 2)  }}fibonacci(18)The result of executing the script is: 2584.DiscussionIt took me a bit of time to find the right system instruction to get Groovy scripts that complied to my requirements. However, I noticed sometimes some internal errors returned by the model, which I haven’t fully understood (and particularly why those happen at all)On some occasions, I also noticed that LangChain4j keeps sending the same script for execution, in a loop. Same thing: I still have to investigate why this rare behavior happens.So this solution is a fun experiment, but I’d call it just that, an experiment, as it’s not as rock-solid as I want it to be. But if I manage to make it more bullet-proof, maybe I could contribute it back as a dedicated execution engine for LangChain4j!Full source codeHere’s the full content of my experiment:import dev.langchain4j.agent.tool.P;import dev.langchain4j.agent.tool.Tool;import dev.langchain4j.memory.chat.MessageWindowChatMemory;import dev.langchain4j.model.vertexai.VertexAiGeminiChatModel;import dev.langchain4j.service.AiServices;import dev.langchain4j.service.SystemMessage;import groovy.lang.GroovyShell;import java.util.Map;public class GroovyCodeInterpreterAssistant {  public static void main(String[] args) {    var model = VertexAiGeminiChatModel.builder()      .project("MY_GCP_PROJECT_ID")      .location("us-central1")      .modelName("gemini-1.5-flash-001")      .maxRetries(1)      .build();    class GroovyInterpreter {      @Tool("Execute a Groovy script and return the result of its execution.")      public Map&lt;String, String&gt; executeGroovyScript(          @P("The groovy script source code to execute")          String groovyScript) {        System.err.format("%n--&gt; Raw Groovy script:%n%s%n", groovyScript);        String script = groovyScript.replace("\\n", "\n");        System.err.format("%n--&gt; Executing:%n%s%n", script);        try {          Object result = new GroovyShell().evaluate(script);          return Map.of("result", result == null ? "null" : result.toString());        } catch (Throwable e) {          return Map.of("error", e.getMessage());        }      }    }    interface GroovyAssistant {      @SystemMessage("""        You are a problem solver equipped with the capability of \        executing Groovy scripts.        When you need to or you're asked to evaluate some math \        function, some algorithm, or some code, use the \        `executeGroovyScript` function, passing a Groovy script \        that implements the function, the algorithm, or the code \        that needs to be run.        In the Groovy script, return a value. Don't print the result \        to the console.        Don't use semicolons in your Groovy scripts, it's not necessary.        When reporting the result of the execution of a script, \        be sure to show the content of that script.        Call the `executeGroovyScript` function only once, \        don't call it in a loop.        """)      String chat(String msg);    }    var assistant = AiServices.builder(GroovyAssistant.class)      .chatLanguageModel(model)      .chatMemory(MessageWindowChatMemory.withMaxMessages(20))      .tools(new GroovyInterpreter())      .build();    System.out.println(      assistant.chat(        "Write a `fibonacci` function, and calculate `fibonacci(18)`"));  }}Originally published at https://glaforge.dev on June 3, 2024.Let’s make Gemini Groovy! was originally published in Google Cloud - Community on Medium, where people are continuing the conversation by highlighting and responding to this story.

== Article 2
* Title: 'Grounding Gemini with Web Search results in LangChain4j'
* Author: 'Guillaume Laforge'
* URL: 'https://medium.com/google-cloud/grounding-gemini-with-web-search-results-in-langchain4j-2f949bd69492?source=rss-431147437aeb------2'
* PublicationDate: 'Tue, 28 May 2024 00:00:35 GMT'
* Categories: generative-ai, google-cloud-platform, langchain4j, gemini, java

The latest release of LangChain4j (version 0.31) added the capability of grounding large language models with results from web searches. There’s an integration with Google Custom Search Engine, and also Tavily.The fact of grounding an LLM’s response with the results from a search engine allows the LLM to find relevant information about the query from web searches, which will likely include up-to-date information that the model won’t have seen during its training, past its cut-off date when the training ended.Remark: Gemini has a built-in Google Web Search grounding capability, however, LangChain4j’s Gemini integration doesn’t yet surface this feature. I’m currently working on a pull request to support this.Asking questions to your websiteAn interesting use case for LLM web search grounding is for example if you want to search a particular website. I was interested in asking questions related to articles that I have posted on my personal website and blog. Let’s see, step by step, how you can implement this.Creating a custom search engineFirst of all, as I decided to use Google Custom Search, I created a new custom search engine. I won’t detail the steps involved in this process, as it’s explained in the documentation. I created a custom search searching only the content on my website: glaforge.dev. But you can potentially search the whole internet if you wish, or just your company website, etc.Google Custom Search gave me an API key, as well as a Custom Search ID (csi) for my newly created custom search engine. You can test the custom search engine with that ID with this URL: https://programmablesearchengine.google.com/controlpanel/overview?cx=YOUR_CSI_HERE. It gives you a Google Search-like interface where you can enter your queries. There’s also a widget that you can integrate in your website if you wish.ImplementationFirst of all, I configure the chat model I want to use. I’m using the latest and fastest Gemini model: Gemini 1.5 Flash. I’ve saved my Google Cloud project ID and location in environment variables.VertexAiGeminiChatModel model = VertexAiGeminiChatModel.builder()    .project(System.getenv("PROJECT_ID"))    .location(System.getenv("LOCATION"))    .modelName("gemini-1.5-flash-001")    .build();Next, I configure my web search engine. Here, I’m using Google Search, but it could be Tavily as well. I also saved my API key and the ID of my custom web search in environment variables:WebSearchEngine webSearchEngine = GoogleCustomWebSearchEngine.builder()    .apiKey(System.getenv("GOOGLE_CUSTOM_SEARCH_API_KEY"))    .csi(System.getenv("GOOGLE_CUSTOM_SEARCH_CSI"))//    .logRequests(true)//    .logResponses(true)    .build();Note that you can log the requests and responses, for debugging purpose.Next, I define a content retriever, this is a way to let LangChain4j know that content can be retrieved from a particular tool or location:ContentRetriever contentRetriever = WebSearchContentRetriever.builder()    .webSearchEngine(webSearchEngine)    .maxResults(3)    .build();Now, I define the contract I want to use to interact with my Gemini model, by creating my own custom search interface:interface SearchWebsite {    String search(String query);}This interface will be implemented by LangChain4j’s AiServices system that binds several components together: the chat language model (here, Gemini), and the web search content retriever I created above:SearchWebsite website = AiServices.builder(SearchWebsite.class)    .chatLanguageModel(model)    .contentRetriever(contentRetriever)    .build();Then I can ask my question to the LLM, which will find the relevant information in my blog:String response = website.search(    "How can I call the Gemma model from LangChain4j?");System.out.println("response = " + response);If I comment out the line contentRetriever(contentRetriever), Gemini does a best effort at answering my question, but since there's nothing in its training data (before its cut-off date) about how to call the Gemma model from LangChain4j, it is not able to provide a useful answer.But with the web search content retriever, Gemini is able to find the right material to ground its answer, as the custom search returns my article on calling Gemma with Ollama, Testcontainers, and LangChain4j:Based on the provided information, you can call the Gemma model from LangChain4j using the following approach:1. **Use Ollama:** The articles highlight Ollama as a tool for interacting with Gemma. You would need to set up Ollama and ensure it has access to the Gemma model.2. **Integrate TestContainers:** TestContainers helps you manage containerized environments for testing. You can use it to run Ollama within a container alongside LangChain4j.3. **Utilize LangChain4j:** LangChain4j provides the framework for interacting with large language models. You would define your prompt, send it to Ollama (which runs Gemma), and receive the response back through LangChain4j.**Example Steps:**1. **Set up Ollama:** Install Ollama and configure it to use the Gemma model.2. **Create a Dockerfile:** Use a Dockerfile to define an image that includes Ollama and any dependencies.3. **Run Ollama in a container using TestContainers:** Start the container using TestContainers and ensure it is accessible from your LangChain4j code.4. **Implement LangChain4j calls:** Use LangChain4j to construct your prompt and send it to Ollama (which will pass it to Gemma).5. **Receive and process the response:** Receive the generated response from Gemma and process it as needed in your Java application.**Note:** These steps provide a general approach. You will need to refer to the documentation for Ollama, TestContainers, and LangChain4j for specific implementation details.This method leverages Ollama as an intermediary to access Gemma. If you have access to Google’s Gemini model directly, you might be able to integrate it with LangChain4j without the Ollama step, depending on the specific API or SDK offered by Google.The LLM found that I have to use Ollama and TestContainers, as explained in my article. This information wasn’t part of my query, so it proves that it really found the info in the article.DiscussionThe LLM based its answer on the excerpts contained in the search results, not the whole content of the article, so some aspects of this answer are not totally correct: For instance, you don’t have to install Ollama or create your own Dockerfile.To make the response perfect, I believe we would have to combine web search results with Retrieval Augmented Generation, or pass the whole context of the article to the model, so that it could provide a more thorough and factual answer.For different queries that lead to shorter answers, the answer would probably be more to the point.Another approach is to annotate our String search(String query) method with a @SystemInstruction() with instructions that encourage the LLM to provide a shorter answer. But it's difficult to find the right balance between too long and too short, and of course without any sort of hallucinations!For example, you can try with the following system instruction:I got the following response:The provided information mentions using Gemma with Ollama, TestContainers, and LangChain4j. You can use Ollama, a local LLM server, and TestContainers, which provides lightweight, disposable containers, to set up a testing environment. Then, with LangChain4j, a Java library for interacting with LLMs, you can call Gemma through the Ollama server.Which is shorter and more factual, without being too short either!What’s next?In an upcoming article, I’ll show you how to use Gemini’s built-in Google Search grounding, but first, I have to finish my pull request for the LangChain4j project!Or I can explore how to reply more precisely to queries that lead to complex answers like the above, maybe combinging a RAG approach to get the full context of the article found by the web search.Also, the Tavily API seems to be able to return the raw content of the article, so maybe it can help giving the LLM the full context of the article to base its answers on it. So that may be worth comparing those two web search integrations too.Stay tuned!Full sample codeFor reference, here is the full sample (with the system instruction approach):import dev.langchain4j.model.vertexai.VertexAiGeminiChatModel;import dev.langchain4j.rag.content.retriever.ContentRetriever;import dev.langchain4j.rag.content.retriever.WebSearchContentRetriever;import dev.langchain4j.service.AiServices;import dev.langchain4j.service.SystemMessage;import dev.langchain4j.web.search.WebSearchEngine;import dev.langchain4j.web.search.google.customsearch.GoogleCustomWebSearchEngine;public class GroundingWithSearch {  public static void main(String[] args) {    VertexAiGeminiChatModel model = VertexAiGeminiChatModel.builder()      .project(System.getenv("PROJECT_ID"))      .location(System.getenv("LOCATION"))      .modelName("gemini-1.5-flash-001")      .build();    WebSearchEngine webSearchEngine = GoogleCustomWebSearchEngine.builder()      .apiKey(System.getenv("GOOGLE_CUSTOM_SEARCH_API_KEY"))      .csi(System.getenv("GOOGLE_CUSTOM_SEARCH_CSI"))//    .logRequests(true)//    .logResponses(true)      .build();    ContentRetriever contentRetriever = WebSearchContentRetriever.builder()      .webSearchEngine(webSearchEngine)      .maxResults(3)      .build();    interface SearchWebsite {      @SystemMessage("""        Provide a paragraph-long answer, not a long step by step explanation.        Reply with "I don't know the answer" if the provided information isn't relevant.        """)      String search(String query);    }    SearchWebsite website = AiServices.builder(SearchWebsite.class)      .chatLanguageModel(model)      .contentRetriever(contentRetriever)      .build();    String response = website.search(      "How can I call the Gemma model from LangChain4j?");    System.out.println("response = " + response);  }}Originally published at https://glaforge.dev on May 28, 2024.Grounding Gemini with Web Search results in LangChain4j was originally published in Google Cloud - Community on Medium, where people are continuing the conversation by highlighting and responding to this story.

== Article 3
* Title: 'Calling Gemma with Ollama, TestContainers, and LangChain4j'
* Author: 'Guillaume Laforge'
* URL: 'https://medium.com/google-cloud/calling-gemma-with-ollama-testcontainers-and-langchain4j-fbfe220ca715?source=rss-431147437aeb------2'
* PublicationDate: 'Wed, 03 Apr 2024 00:00:55 GMT'
* Categories: gcp-app-dev, ollama, google-cloud-platform, testcontainer, langchain4j

Lately, for my Generative AI powered Java apps, I’ve used the Gemini multimodal large language model from Google. But there’s also Gemma, its little sister model.Gemma is a family of lightweight, state-of-the-art open models built from the same research and technology used to create the Gemini models. Gemma is available in two sizes: 2B and 7B. Its weights are freely available, and its small size means you can run it on your own, even on your laptop. So I was curious to give it a run with LangChain4j.How to run GemmaThere are many ways to run Gemma: in the cloud, via Vertex AI with a click of a button, or GKE with some GPUs, but you can also run it locally with Jlama or Gemma.cpp.Another good option is to run Gemma with Ollama, a tool that you install on your machine, and which lets you run small models, like Llama 2, Mistral, and many others. They quickly added support for Gemma as well.Once installed locally, you can run:ollama run gemma:2bollama run gemma:7bCherry on the cake, the LangChain4j library provides an Ollama module, so you can plug Ollama supported models in your Java applications easily.ContainerizationAfter a great discussion with my colleague Dan Dobrin who had worked with Ollama and TestContainers (#1 and#2) in his serverless production readiness workshop, I decided to try the approach below.Which brings us to the last piece of the puzzle: Instead of having to install and run Ollama on my computer, I decided to use Ollama within a container, handled by TestContainers.TestContainers is not only useful for testing, but you can also use it for driving containers. There’s even a specific OllamaContainer you can take advantage of!So here’s the whole picture:Time to implement this approach!You’ll find the code in the Github repository accompanying my recent Gemini workshopLet’s start with the easy part, interacting with an Ollama supported model with LangChain4j:OllamaContainer ollama = createGemmaOllamaContainer();ollama.start();ChatLanguageModel model = OllamaChatModel.builder()    .baseUrl(String.format("http://%s:%d", ollama.getHost(), ollama.getFirstMappedPort()))    .modelName("gemma:2b")    .build();String response = model.generate("Why is the sky blue?");System.out.println(response);You run an Ollama test container.You create an Ollama chat model, by pointing at the address and port of the container.You specify the model you want to use.Then, you just need to call model.generate(yourPrompt) as usual.Easy? Now let’s have a look at the trickier part, my local method that creates the Ollama container:// check if the custom Gemma Ollama image exists alreadyList&lt;Image&gt; listImagesCmd = DockerClientFactory.lazyClient()    .listImagesCmd()    .withImageNameFilter(TC_OLLAMA_GEMMA_2_B)    .exec();if (listImagesCmd.isEmpty()) {    System.out.println("Creating a new Ollama container with Gemma 2B image...");    OllamaContainer ollama = new OllamaContainer("ollama/ollama:0.1.26");    ollama.start();    ollama.execInContainer("ollama", "pull", "gemma:2b");    ollama.commitToImage(TC_OLLAMA_GEMMA_2_B);    return ollama;} else {    System.out.println("Using existing Ollama container with Gemma 2B image...");    // Substitute the default Ollama image with our Gemma variant    return new OllamaContainer(        DockerImageName.parse(TC_OLLAMA_GEMMA_2_B)            .asCompatibleSubstituteFor("ollama/ollama"));}You need to create a derived Ollama container that pulls in the Gemma model. Either this image was already created beforehand, or if it doesn’t exist yet, you create it.Use the Docker Java client to check if the custom Gemma image exists. If it doesn’t exist, notice how TestContainers let you create an image derived from the base Ollama image, pull the Gemma model, and then commit that image to your local Docker registry.Otherwise, if the image already exists (ie. you created it in a previous run of the application), you’re just going to tell TestContainers that you want to substitute the default Ollama image with your Gemma-powered variant.And voila!You can call Gemma locally on your laptop, in your Java apps, using LangChain4j, without having to install and run Ollama locally (but of course, you need to have a Docker daemon running).Big thanks to Dan Dobrin for the approach, and to Sergei, Eddú and Oleg from TestContainers for the help and useful pointers.Originally published at https://glaforge.dev on April 3, 2024.Calling Gemma with Ollama, TestContainers, and LangChain4j was originally published in Google Cloud - Community on Medium, where people are continuing the conversation by highlighting and responding to this story.

== Article 4
* Title: 'Gemini codelab for Java developers using LangChain4j'
* Author: 'Guillaume Laforge'
* URL: 'https://medium.com/google-cloud/gemini-codelab-for-java-developers-using-langchain4j-769fbd419756?source=rss-431147437aeb------2'
* PublicationDate: 'Wed, 27 Mar 2024 00:00:46 GMT'
* Categories: langchain4j, gemini, google-cloud-platform, gcp-app-dev, java

No need to be a Python developer to do Generative AI! If you’re a Java developer, you can take advantage of LangChain4j to implement some advanced LLM integrations in your Java applications. And if you’re interested in using Gemini, one of the best models available, I invite you to have a look at the following “codelab” that I worked on:Codelab — Gemini for Java Developers using LangChain4jIn this workshop, you’ll find various examples covering the following use cases, in crescendo approach:Making your fist call to Gemini (streaming &amp; non-streaming)Maintaining a conversationTaking advantage of multimodality by analysing images with your promptsExtracting structured information from unstructured textUsing prompt templatesDoing text classification with few-shot promptingImplementing Retrieval Augmented Generation to chat with your documentationHow to do Function Calling to expand the LLM to interact with external APIs and servicesYou’ll find all the code samples on Github.If you’re attending Devoxx France, be sure to attend the Hands-on-Lab workshop with my colleagues Mete Atamel and Valentin Deleplace who will guide you through this codelab.Originally published at https://glaforge.dev on March 27, 2024.Gemini codelab for Java developers using LangChain4j was originally published in Google Cloud - Community on Medium, where people are continuing the conversation by highlighting and responding to this story.

== Article 5
* Title: 'Visualize PaLM-based LLM tokens'
* Author: 'Guillaume Laforge'
* URL: 'https://medium.com/google-cloud/visualize-palm-based-llm-tokens-8760b3122c0f?source=rss-431147437aeb------2'
* PublicationDate: 'Mon, 05 Feb 2024 00:00:45 GMT'
* Categories: llm, google-cloud-platform, gcp-app-dev, vertex-ai, generative-ai-tools

As I was working on tweaking the Vertex AI text embedding model in LangChain4j, I wanted to better understand how the textembedding-geckomodel tokenizes the text, in particular when we implement the Retrieval Augmented Generation approach.The various PaLM-based models offer a computeTokens endpoint, which returns a list of tokens (encoded in Base 64) and their respective IDs.Note: At the time of this writing, there’s no equivalent endpoint for Gemini models.So I decided to create a small application that lets users:input some text,select a model,calculate the number of tokens,and visualize them with some nice pastel colors.The available PaLM-based models are:textembedding-geckotextembedding-gecko-multilingualtext-bisontext-unicornchat-bisoncode-geckocode-bisoncodechat-bisonYou can try the application online.And also have a look at the source code on Github. It’s a Micronaut application. I serve the static assets as explained in my recent article. I deployed the application on Google Cloud Run, the easiest way to deploy a container, and let it auto-scale for you. I did a source based deployment, as explained at the bottom here.And voilà I can visualize my LLM tokens!Originally published at https://glaforge.dev on February 5, 2024.Visualize PaLM-based LLM tokens was originally published in Google Cloud - Community on Medium, where people are continuing the conversation by highlighting and responding to this story.

== Article 6
* Title: 'Image generation with Imagen and LangChain4j'
* Author: 'Guillaume Laforge'
* URL: 'https://medium.com/google-cloud/image-generation-with-imagen-and-langchain4j-61ca08ae6aac?source=rss-431147437aeb------2'
* PublicationDate: 'Thu, 01 Feb 2024 00:00:35 GMT'
* Categories: google-cloud-platform, imagen, java, langchain, generative-ai-use-cases

This week LangChain4j, the LLM orchestration framework for Java developers, released version 0.26.1, which contains my first significant contribution to the open source project: support for the Imagen image generation model.Imagen is a text-to-image diffusion model that was announced last year. And it recently upgraded to Imagen v2, with even higher quality graphics generation. As I was curious to integrate it in some of my generative AI projects, I thought that would be a great first contribution to LangChain4j.Caution: At the time of this writing, image generation is still only for allow-listed accounts.Furthermore, to run the snippets covered below, you should have an account on Google Cloud Platform, created a project, configured a billing account, enabled the Vertex AI API, and authenticated with the gcloud SDK and the command: gcloud auth application-default login.Now let’s dive in how to use Imagen v1 and v2 with LangChain4j in Java!Generate your first imagesIn the following examples, I’m using the following constants, to point at my project details, the endpoint, the region, etc:private static final String ENDPOINT = "us-central1-aiplatform.googleapis.com:443";private static final String LOCATION = "us-central1";private static final String PROJECT = "YOUR_PROJECT_ID";private static final String PUBLISHER = "google";First, we’re going to create an instance of the model:VertexAiImageModel imagenModel = VertexAiImageModel.builder()    .endpoint(ENDPOINT)    .location(LOCATION)    .project(PROJECT)    .publisher(PUBLISHER)    .modelName("imagegeneration@005")    .maxRetries(2)    .withPersisting()    .build();There are 2 models you can use:imagegeneration@005 corresponds to Imagen 2imagegeneration@002 is the previous version (Imagen 1)In this article, we’ll use both models. Why? Because currently Imagen 2 doesn’t support image editing, so we’ll have to use Imagen 1 for that purpose.The configuration above uses withPersisting() to save the generated images in a temporary folder on your system. If you don't persist the image files, the content of the image is avaiable as Base 64 encoded bytes in the Images objects returned. You can also specify persistTo(somePath) to specify a particular directory where you want the generated files to be saved.Let’s create our first image:Response&lt;Image&gt; imageResponse = imagenModel.generate(    "watercolor of a colorful parrot drinking a cup of coffee");The Response object wraps the created Image. You can get the Image by calling imageResponse.getContent(). And you can retrieve the URL of the image (if saved locally) with imageResponse.getContent().url(). The Base 64 encoded bytes can be retrieved with imageResponse.getContent().base64Data()Some other tweaks to the model configuration:Specify the language of the prompt: language("ja") (if the language is not officially supported, it's usually translated back to English anyway).Define a negative prompt with things you don’t want to see in the picture: negativePrompt("black feathers").Use a particular seed to always generate the same image with the same seed: seed(1234L).So if you want to generate a picture of a pizza with a prompt in Japanese, but you don’t want to have pepperoni and pineapple, you could configure your model and generate as follows:VertexAiImageModel imagenModel = VertexAiImageModel.builder()        .endpoint(ENDPOINT)        .location(LOCATION)        .project(PROJECT)        .publisher(PUBLISHER)        .modelName("imagegeneration@005")        .language("ja")        .negativePrompt("pepperoni, pineapple")        .maxRetries(2)        .withPersisting()        .build();Response&lt;Image&gt; imageResponse = imagenModel.generate("ピザ"); // pizzaImage editing with Imagen 1With Imagen 1, you can edit existing images:mask-based editing: you can specify a mask, a black &amp; white image where the white parts are the corresponding parts of the original image that should be edited,mask free editing: where you just give a prompt and let the model figure out what should be edited on its own or following the prompt.When generating and editing with Imagen 1, you can also configure the model to use a particular style (with Imagen 2, you just specify it in the prompt) with sampleImageStyle(VertexAiImageModel.ImageStyle.photograph):- photograph- digital_art- landscape- sketch- watercolor- cyberpunk- pop_artWhen editing an image, you may wish to decide how strong or not the modification should be, with .guidanceScale(100). Usually, between 0 and 20 or so, it's lightly edited, between 20 and 100 it's getting more impactful edits, and 100 and above it's the maximum edition level.Let’s say I generated an image of a lush forrest (I’ll use that as my original image):VertexAiImageModel model = VertexAiImageModel.builder()        .endpoint(ENDPOINT)        .location(LOCATION)        .project(PROJECT)        .publisher(PUBLISHER)        .modelName("imagegeneration@002")        .seed(19707L)        .sampleImageStyle(VertexAiImageModel.ImageStyle.photograph)        .guidanceScale(100)        .maxRetries(4)        .withPersisting()        .build();Response&lt;Image&gt; forestResp = model.generate("lush forest");Now I want to edit my forrest to add a small red tree in the bottom of the image. I’m loading a black and white mask image with a white square at the bottom. And I pass the original image, the mask image, and the modification prompt, to the new edit() method:URI maskFileUri = getClass().getClassLoader().getResource("mask.png").toURI();Response&lt;Image&gt; compositeResp = model.edit(        forestResp.content(),              // original image to edit        fromPath(Paths.get(maskFileUri)),  // the mask image        "red trees"                        // the new prompt);Another kind of editing you can do is to upscale an existing image. As far as I know, it’s only supported for Imagen v1 for now, so we’ll continue with that model.In this example, we’ll generate an image of 1024x1024 pixels, and we’ll scale it to 4096x4096:VertexAiImageModel imagenModel = VertexAiImageModel.builder()        .endpoint(ENDPOINT)        .location(LOCATION)        .project(PROJECT)        .publisher(PUBLISHER)        .modelName("imagegeneration@002")        .sampleImageSize(1024)        .withPersisting()        .persistTo(defaultTempDirPath)        .maxRetries(3)        .build();Response&lt;Image&gt; imageResponse =        imagenModel.generate("A black bird looking itself in an antique mirror");VertexAiImageModel imagenModelForUpscaling = VertexAiImageModel.builder()        .endpoint(ENDPOINT)        .location(LOCATION)        .project(PROJECT)        .publisher(PUBLISHER)        .modelName("imagegeneration@002")        .sampleImageSize(4096)        .withPersisting()        .persistTo(defaultTempDirPath)        .maxRetries(3)        .build();Response&lt;Image&gt; upscaledImageResponse =        imagenModelForUpscaling.edit(imageResponse.content(), "");And now you have a much bigger image!ConclusionThat’s about it for image generation and editing with Imagen in LangChain4j today! Be sure to use LangChain4j v0.26.1 which contains that new integration. And I’m looking forward to seeing the pictures you generate with it!Originally published at https://glaforge.dev on February 1, 2024.Image generation with Imagen and LangChain4j was originally published in Google Cloud - Community on Medium, where people are continuing the conversation by highlighting and responding to this story.

== Article 7
* Title: 'Gemini Function Calling'
* Author: 'Guillaume Laforge'
* URL: 'https://medium.com/google-cloud/gemini-function-calling-1585c044d28d?source=rss-431147437aeb------2'
* PublicationDate: 'Fri, 22 Dec 2023 00:00:37 GMT'
* Categories: java, gcp-app-dev, google-cloud-platform, vertex-ai, gemini

A promising feature of the Gemini large language model released recently by Google DeepMind, is the support for function calls. It’s a way to supllement the model, by letting it know an external functions or APIs can be called. So you’re not limited by the knowledge cut-off of the model: instead, in the flow of the conversation with the model, you can pass a list of functions the model will know are available to get the information it needs, to complete the generation of its answer.For example, if you want to ask the model about the weather, it doesn’t have the realtime information about the weather forecast. But we can tell it that there’s a function that can be called, to get the forecast for a given location. Internally, the model will acknowledge it doesn’t know the answer about the weather, but it will request that you call an external function that you describe, using a specific set of parameters which correspond to the user’s request.Just days ago, I wrote about how to get started with Gemini in Java. In that article, we explored how to use the hand-written Java SDK that is available to interact with Gemini from Java. However, the Java SDK doesn’t yet expose all the features of the model: in particular, function calling is missing. But not all hope is lost! Because under the hood, the SDK relies on the generated protobuf classes library, which exposes everything!Soon, Gemini will be supported by LangChain4j, and the Java SDK will also provide an easier way to take care of function calling. But in this article, I wanted to explore the use of the internal protobuf classes, to see how to best implement its support in the SDK.Let’s go step by step!Instead of using the GenerativeModel API from the SDK, we'll go straight with the PredictionServiceClient:try (VertexAI vertexAI = new VertexAI(projectId, location)) {  PredictionServiceClient client = vertexAI.getPredictionServiceClient();  ...}We need to prepare a function declaration to describe the kind of functions that the LLM can ask us to call, and we’ll wrap it in a Tool:FunctionDeclaration functionDeclaration = FunctionDeclaration.newBuilder()    .setName("getCurrentWeather")    .setDescription("Get the current weather in a given location")    .setParameters(        Schema.newBuilder()            .setType(Type.OBJECT)            .putProperties("location", Schema.newBuilder()                .setType(Type.STRING)                .setDescription("location")                .build()            )            .addRequired("location")            .build()    )    .build();Tool tool = Tool.newBuilder()    .addFunctionDeclarations(functionDeclaration)    .build();Functions are described using classes that represent a subset of the OpenAPI 3 specification.This is important to provide descriptions for the functions and its parameters, as the LLM will use that information to figure out which function to call, and which parameters should be passed.Next, let’s prepare a question asking about the weather in Paris, and configuring the text generation request with that prompt and the tool defined above:String resourceName = String.format(    "projects/%s/locations/%s/publishers/google/models/%s",    vertexAI.getProjectId(), vertexAI.getLocation(), modelName);Content questionContent =    ContentMaker.fromString("What's the weather in Paris?");GenerateContentRequest questionContentRequest =    GenerateContentRequest.newBuilder()        .setEndpoint(resourceName)        .setModel(resourceName)        .addTools(tool)        .addContents(questionContent)        .build();ResponseStream&lt;GenerateContentResponse&gt; responseStream =    new ResponseStream&lt;&gt;(new ResponseStreamIteratorWithHistory&lt;&gt;(        client            .streamGenerateContentCallable()            .call(questionContentRequest)            .iterator()));GenerateContentResponse generateContentResponse =    responseStream.stream().findFirst().get();Content callResponseContent =    generateContentResponse.getCandidates(0).getContent();If you print the callResponseContent variable, you'll see that it contains a function call request, suggesting that you should call the predefined function with the parameter of Paris:role: "model"parts {  function_call {    name: "getCurrentWeather"    args {      fields {        key: "location"        value {          string_value: "Paris"        }      }    }  }}At that point, as the developer, it’s your turn to work a little, and make the call to that function yourself! Let’s pretend I called an external Web Service that gives weather information, and that it returns some JSON payload that would look like so:{  "weather": "sunny",  "location": "Paris"}We need now to create a function response structure to pass that information back to the LLM:Content contentFnResp = Content.newBuilder()    .addParts(Part.newBuilder()        .setFunctionResponse(            FunctionResponse.newBuilder()                .setResponse(                    Struct.newBuilder()                        .putFields("weather",                            Value.newBuilder().setStringValue("sunny").build())                        .putFields("location",                            Value.newBuilder().setStringValue("Paris").build())                        .build()                )                .build()        )        .build())    .build();Then, since LLMs are actually stateless beasts, we need to give it the whole context of the conversation again, passing the query, the function call response the model suggested us to make, as well as the response we got from the external weather service:GenerateContentRequest generateContentRequest = GenerateContentRequest.newBuilder()    .setEndpoint(resourceName)    .setModel(resourceName)    .addContents(questionContent)    .addContents(callResponseContent)    .addContents(contentFnResp)    .addTools(tool)    .build();And to finish, we’ll invoke the client one last time with that whole dialog and information, and print a response out:responseStream = new ResponseStream&lt;&gt;(new ResponseStreamIteratorWithHistory&lt;&gt;(    client        .streamGenerateContentCallable()        .call(generateContentRequest)        .iterator()));for (GenerateContentResponse resp : responseStream) {    System.out.println(ResponseHandler.getText(resp));}And happily, Gemini will reply to us that:The weather in Paris is sunny.What a lovely way to start the holiday season with a nice and sunny weather!I wish you all happy year end festivities, and I look forward to seeing you next year. Hopefully next month, I’ll be able to show you some cool new SDK features or the LangChain4j integration! Thanks for reading.Originally published at https://glaforge.dev on December 22, 2023.Gemini Function Calling was originally published in Google Cloud - Community on Medium, where people are continuing the conversation by highlighting and responding to this story.

== Article 8
* Title: 'Visualize and Inspect Workflows Executions'
* Author: 'Guillaume Laforge'
* URL: 'https://medium.com/google-cloud/visualize-and-inspect-workflows-executions-00aafe188d3d?source=rss-431147437aeb------2'
* PublicationDate: 'Fri, 22 Dec 2023 00:00:27 GMT'
* Categories: gcp-workflows, workflow, debugging, google-cloud-platform

When using a service like Google Cloud Workflows, in particular as your workflows get bigger, it can be difficult to understand what’s going on under the hood. With multiple branches, step jumps, iterations, and also parallel branches and iterations, if your workflow fails during an execution, until now, you had to check the execution status, or go deep through the logs to find more details about the failed step.I have good news for you! Workflows recently added some deeper introspection capability: you can now view the history of execution steps. From the Google Cloud console, you can see the lists of steps, and see the logical flow between them. The usual workflow visualisation will also highlight in green the successful steps, and in red the failed one. Of course, it is also possible to make a curl call to get the JSON of the list of executed steps.Let’s have a look!In the console, when you click on an execution, in the summary tab, you'll see not only the failed step, but also the nice workflow graph colored green and red:That way, you know which path the execution followed, in a visual manner. But you can also see the actual list of steps executed, with more details, by clicking on the steps tab:From this table, the filter will let you further refine particular type of steps you’d like to investigate, or visualise the steps of a subworkflow only, etc.This is a nice improvement to the developer experience, and for your ops team, to better understand what happens during your workflow executions! Feel free to read more about this new capabability in the documentation about viewing the history of execution steps.Originally published at https://glaforge.dev on December 22, 2023.Visualize and Inspect Workflows Executions was originally published in Google Cloud - Community on Medium, where people are continuing the conversation by highlighting and responding to this story.

== Article 9
* Title: 'Hands on Codelabs to dabble with Large Language Models in Java'
* Author: 'Guillaume Laforge'
* URL: 'https://medium.com/google-cloud/hands-on-codelabs-to-dabble-with-large-language-models-in-java-ee7bc330f5fe?source=rss-431147437aeb------2'
* PublicationDate: 'Mon, 18 Dec 2023 00:00:36 GMT'
* Categories: llm, generative-ai, java, google-cloud-platform, langchain

Hot on the heels of the release of Gemini, I’d like to share a couple of resources I created to get your hands on large language models, using LangChain4J, and the PaLM 2 model. Later on, I’ll also share with you articles and codelabs that take advantage of Gemini, of course.The PaLM 2 model supports 2 modes:text generation,and chat.In the 2 codelabs, you’ll need to have created an account on Google Cloud, and created a project. The codelabs will guide you through the steps to setup the environment, and show you how to use the Google Cloud built-in shell and code editor, to develop in the cloud.You should be a Java developer, as the examples are in Java, use the LangChain4J project, and Maven for building the code.Generative AI text generation in Java with PaLM and LangChain4JIn the first codelab you can explore:how to make your first call to PaLM for simple question/answer scenarioshow to extract structured data out of unstructured texthow to use prompts and prompt templateshow to classify text, with an example on sentiment analysisGenerative AI powered chat with users and docs in Java with PaLM and LangChain4JIn the second codelab you’ll use the chat model to learn:how to create your first chat with the PaLM modelhow to give your chatbot a personality, with an example with a chess playerhow to extract structured data out of unstructured text using LangChain4J’s AiServices and its annotationshow to implement Retrieval Augmented Generation (RAG) to answer questions about your own documentationGoing further with Generative AIIf you’re interested in going further with Generative AI, and learn more, feel free to join the Google Cloud Innovators program.Google Cloud Innovators is free and includes:live discussions, AMAs, and roadmap sessions to learn the latest directly from Googlers,the latest Google Cloud news right in your inbox,digital badge and video conference background,500 credits of labs and learning on Skills Boost.Originally published at https://glaforge.dev on December 18, 2023.Hands on Codelabs to dabble with Large Language Models in Java was originally published in Google Cloud - Community on Medium, where people are continuing the conversation by highlighting and responding to this story.

== Article 10
* Title: 'Get Started with Gemini in Java'
* Author: 'Guillaume Laforge'
* URL: 'https://medium.com/google-cloud/get-started-with-gemini-in-java-923f2069ea4d?source=rss-431147437aeb------2'
* PublicationDate: 'Wed, 13 Dec 2023 00:00:25 GMT'
* Categories: java, gcp-app-dev, generative-ai-tools, google-cloud-platform, machine-learning

Google announced today the availability of Gemini, its latest and more powerful Large Language Model. Gemini is multimodal, which means it’s able to consume not only text, but also images or videos.I had the pleasure of working on the Java samples and help with the Java SDK, with wonderful engineer colleagues, and I’d like to share some examples of what you can do with Gemini, using Java!First of all, you’ll need to have an account on Google Cloud and created a project. The Vertex AI API should be enabled, to be able to access the Generative AI services, and in particular the Gemini large language model. Be sure to check out the instructions.Preparing your project buildTo get started with some coding, you’ll need to create a Gradle or a Maven build file that requires the Google Cloud libraries BOM, and the google-cloud-vertexai library. Here's an example with Maven:...&lt;dependencyManagement&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;artifactId&gt;libraries-bom&lt;/artifactId&gt;            &lt;groupId&gt;com.google.cloud&lt;/groupId&gt;            &lt;scope&gt;import&lt;/scope&gt;            &lt;type&gt;pom&lt;/type&gt;            &lt;version&gt;26.29.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.google.cloud&lt;/groupId&gt;        &lt;artifactId&gt;google-cloud-vertexai&lt;/artifactId&gt;    &lt;/dependency&gt;    ...&lt;/dependencies&gt;...Your first queriesNow let’s have a look at our first multimodal example, mixing text prompts and images:try (VertexAI vertexAI = new VertexAI(projectId, location)) {    byte[] imageBytes = Base64.getDecoder().decode(dataImageBase64);    GenerativeModel model = new GenerativeModel("gemini-pro-vision", vertexAI);    GenerateContentResponse response = model.generateContent(        ContentMaker.fromMultiModalData(            "What is this image about?",            PartMaker.fromMimeTypeAndData("image/jpg", imageBytes)        ));    System.out.println(ResponseHandler.getText(response));}You instantiate VertexAI with your Google Cloud project ID, and the region location of your choice. To pass images to Gemini, you should either pass the bytes directly, or you can pass a URI of an image stored in a cloud storage bucket (like gs://my-bucket/my-img.jpg). You create an instance of the model. Here, I'm using gemini-pro-vision. But later on, a gemini-ultra-vision model will also be available. Let's ask the model to generate content with the generateContent() method, by passing both a text prompt, and also an image. The ContentMaker and PartMaker classes are helpers to further simplify the creation of more advanced prompts that mix different modalities. But you could also just pass a simple string as argument of the generateContent() method. The ResponseHandler utility will retrieve all the text of the answer of the model.Instead of getting the whole output once all the text is generated, you can also adopt a streaming approach:model.generateContentStream("Why is the sky blue?")    .stream()    .forEach(System.out::print);You can also iterate over the stream with a for loop:ResponseStream&lt;GenerateContentResponse&gt; responseStream =    model.generateContentStream("Why is the sky blue?");for (GenerateContentResponse responsePart: responseStream) {    System.out.print(ResponseHandler.getText(responsePart));}Let’s chat!Gemini is a multimodal model, and it’s actually both a text generation model, but also a chat model. So you can chat with Gemini, and ask a series of questions in context. There’s a handy ChatSession utility class which simplifies the handling of the conversation:try (VertexAI vertexAI = new VertexAI(projectId, location)) {    GenerateContentResponse response;    GenerativeModel model = new GenerativeModel(modelName, vertexAI);    ChatSession chatSession = new ChatSession(model);    response = chatSession.sendMessage("Hello.");    System.out.println(ResponseHandler.getText(response));    response = chatSession.sendMessage("What are all the colors in a rainbow?");    System.out.println(ResponseHandler.getText(response));    response = chatSession.sendMessage("Why does it appear when it rains?");    System.out.println(ResponseHandler.getText(response));}This is convenient to use ChatSession as it takes care of keeping track of past questions from the user, and answers from the assistant.Going furtherThis is just a few examples of the capabilities of Gemini. Be sure to check out some of the samples that are available on Github. Read more about Gemini and Generative AI in the Google Cloud documentation.Originally published at https://glaforge.dev on December 13, 2023.Get Started with Gemini in Java was originally published in Google Cloud - Community on Medium, where people are continuing the conversation by highlighting and responding to this story.
